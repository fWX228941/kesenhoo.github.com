<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 胡凯]]></title>
  <link href="http://hukai.me/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2016-09-03T16:26:41+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[HuKai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第6季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-6/"/>
    <updated>2016-08-31T23:12:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-6</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_5.png" alt="android_perf_patterns_season_5" /></p>

<blockquote><p>这是<a href="https://www.youtube.com/watch?v=Vw1G1s73DsY&amp;index=74&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第6季的课程学习笔记，最近个人事情比较多，从被@起，这篇学习笔记就一直被惦记着，现在学习记录分享一下，请多多包涵担待指正！这次才一共6个段落，涉及的内容主要有：程序启动时间相关的三个方面：activity的创建过程，臃肿的application启动对象，主题启动显屏。另外还介绍了减少安装包大小的checklist以及如何使用VectorDrawable来减少安装包的大小。</p></blockquote>

<h2>1）App Launch time 101</h2>

<p>提高程序的启动速度意义重大，很显然，启动时间越短，用户才越有耐心等待打开这个APP进行使用，反之启动时间越长，用户则越有可能来不及等到APP打开就已经切换到其他APP了。程序启动过程中的那些复杂错误的操作很可能导致严重的性能问题。Android系统会根据用户的操作行为调整程序的显示策略，用来提高程序的显示性能。例如，一旦用户点击桌面图标，Android系统会立即显示一个启动窗口，这个窗口会一直保持显示直到画面中的元素成功加载并绘制完第一帧。这种行为常见于程序的冷启动，或者程序的热启动场景（程序从后台被唤起或者从其他APP界面切换回来）。那么关键的问题是，用户很可能会因为从启动窗口到显示画面的过程耗时过长而感到厌烦，从而导致用户没有来得及等程序启动完毕就切换到其他APP了。更严重的是，如果启动时间过长，可能导致程序出现ANR。我们应该避免出现这两种糟糕的情况。</p>

<p>从技术角度来说，当用户点击桌面图标开始，系统会立即为这个APP创建独立的专属进程，然后显示启动窗口，直到APP在自己的进程里面完成了程序的创建以及主线程完成了Activity的初始化显示操作，再然后系统进程就会把启动窗口替换成APP的显示窗口。</p>

<p><img src="/images/android_perf_6_launch_time_start_process.png" alt="android_perf_6_launch_time_start_process" /></p>

<p>上述流程里面的绝大多数步骤都是由系统控制的，一般来说不会出现什么问题，可是对于启动速度，我们能够控制并且需要特别关注的地方主要有三处：</p>

<ul>
<li>1）Activity的onCreate流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题。</li>
<li>2）Application的onCreate流程，对于大型的APP来说，通常会在这里做大量的通用组件的初始化操作。</li>
<li>3）目前有部分APP会提供自定义的启动窗口，这里可以做成品牌宣传界面或者是给用户提供一种程序已经启动的视觉效果。</li>
</ul>


<p>在正式着手解决问题之前，我们需要掌握一套正确测量评估启动性能的方法。所幸的是，Android系统有提供一些工具来帮助我们定位问题。</p>

<ul>
<li>1）首先是<strong>display time</strong>：从Android KitKat版本开始，Logcat中会输出从程序启动到某个Activity显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_display_time.png" alt="android_perf_6_launch_time_display_time" /></p>

<ul>
<li>2）其次是<strong>reportFullyDrawn</strong>方法：我们通常来说会使用异步懒加载的方式来提升程序画面的显示速度，这通常会导致的一个问题是，程序画面已经显示，可是内容却还在加载中。为了衡量这些异步加载资源所耗费的时间，我们可以在异步加载完毕之后调用<code>activity.reportFullyDrawn()</code>方法来告诉系统此时的状态，以便获取整个加载的耗时。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_report_fully_drawn.png" alt="android_perf_6_launch_time_report_fully_drawn" /></p>

<ul>
<li>3）然后是<strong>Method Tracing</strong>：前面两个方法提供了启动耗时的总时间，可是却无法提供具体的耗时细节。为了获取具体的耗时分布情况，我们可以使用Method Tracing工具来进行详细的测量。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_method_tracing.png" alt="android_perf_6_launch_time_method_tracing" /></p>

<ul>
<li>4）最后是<strong>Systrace</strong>：我们可以在onCreate方法里面添加trace方法来声明需要跟踪的起止位置，系统会帮忙统计中间经历过的函数调用耗时，并输出报表。</li>
</ul>


<p><img src="/images/android_perf_6_launch_time_systrace.png" alt="android_perf_6_launch_time_systrace" /></p>

<h2>2）</h2>

<p><img src="/images/android_perf_5_threading_main_thread.png" alt="android_perf_5_threading_main_thread" /></p>

<!-- More -->


<hr />

<p>首发于CSDN：<a href="http://ms.csdn.net/geek/71031">Android性能优化典范（五）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google I/O 2016随笔]]></title>
    <link href="http://hukai.me/google-io-2016/"/>
    <updated>2016-05-24T05:06:01+08:00</updated>
    <id>http://hukai.me/google-io-2016</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/oasisfeng">冯老师</a>，<a href="https://github.com/liaohuqiu">秋百万</a>，<a href="http://www.race604.com/">吴晶</a>还有我！四人约好从北京转机一起前往旧金山。</p>

<p><img src="/images/google_io_2016_00.JPG" alt="google_io_2016_00" /></p>

<p>在航班上研究KMP算法的同学</p>

<p><img src="/images/google_io_2016_01.JPG" alt="google_io_2016_01" /></p>

<p>到达旧金山机场，去提取事先租好的车，自驾</p>

<!-- More -->


<p><img src="/images/google_io_2016_02.JPG" alt="google_io_2016_02" /></p>

<p><img src="/images/google_io_2016_03.JPG" alt="google_io_2016_03" /></p>

<p><img src="/images/google_io_2016_04.JPG" alt="google_io_2016_04" /></p>

<p>入住通过Airbnb上找的房子</p>

<p><img src="/images/google_io_2016_05.JPG" alt="google_io_2016_05" /></p>

<p><img src="/images/google_io_2016_06.JPG" alt="google_io_2016_06" /></p>

<p>到美国吃的第一顿（中式餐馆）没预料到这会是之后几天我吃的最满意的一次了</p>

<p><img src="/images/google_io_2016_07.JPG" alt="google_io_2016_07" /></p>

<p>第二天一早清晨，在海边小镇上闲逛</p>

<p><img src="/images/google_io_2016_08.JPG" alt="google_io_2016_08" />
<img src="/images/google_io_2016_09.JPG" alt="google_io_2016_09" />
<img src="/images/google_io_2016_10.JPG" alt="google_io_2016_10" />
<img src="/images/google_io_2016_11.JPG" alt="google_io_2016_11" />
<img src="/images/google_io_2016_12.JPG" alt="google_io_2016_12" /></p>

<p>之后去了旁边的半月湾海边走走，以及不远处的森林公园爬山</p>

<p><img src="/images/google_io_2016_13.JPG" alt="google_io_2016_13" />
<img src="/images/google_io_2016_14.JPG" alt="google_io_2016_14" />
<img src="/images/google_io_2016_15.JPG" alt="google_io_2016_15" /></p>

<p>晚上跑到旧金山最高点，看全市夜景</p>

<p><img src="/images/google_io_2016_16.JPG" alt="google_io_2016_16" /></p>

<p>离开半月湾海边公寓之前的合影（从左至右，依次为吴晶，冯老师，秋百万和我）</p>

<p><img src="/images/google_io_2016_17.JPG" alt="google_io_2016_17" /></p>

<p>窗外的全景</p>

<p><img src="/images/google_io_2016_19.JPG" alt="google_io_2016_19" /></p>

<p>I/O的头一天签到</p>

<p><img src="/images/google_io_2016_21.JPG" alt="google_io_2016_21" />
<img src="/images/google_io_2016_20.JPG" alt="google_io_2016_20" />
<img src="/images/google_io_2016_22.JPG" alt="google_io_2016_22" />
<img src="/images/google_io_2016_23.JPG" alt="google_io_2016_23" />
<img src="/images/google_io_2016_24.JPG" alt="google_io_2016_24" /></p>

<p>顺便参观了下Google总部</p>

<p><img src="/images/google_io_2016_25.JPG" alt="google_io_2016_25" />
<img src="/images/google_io_2016_26.JPG" alt="google_io_2016_26" />
<img src="/images/google_io_2016_27.JPG" alt="google_io_2016_27" />
<img src="/images/google_io_2016_28.JPG" alt="google_io_2016_28" />
<img src="/images/google_io_2016_29.JPG" alt="google_io_2016_29" />
<img src="/images/google_io_2016_30.JPG" alt="google_io_2016_30" /></p>

<p>签到当天晚上，又是一群聚会聊天</p>

<p><img src="/images/google_io_2016_32.JPG" alt="google_io_2016_32" />
<img src="/images/google_io_2016_31.JPG" alt="google_io_2016_31" /></p>

<p>次日I/O正式开场，主会场，分会场持续三天</p>

<p><img src="/images/google_io_2016_33.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_34.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_35.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_36.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_37.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_38.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_39.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_40.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_41.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_42.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_43.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_44.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_45.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_46.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_47.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_48.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_49.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_50.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_51.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_52.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_53.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_54.JPG" alt="google_io_2016_31" />
<img src="/images/google_io_2016_55.JPG" alt="google_io_2016_31" /></p>

<p>用一张合影结尾</p>

<p><img src="/images/google_io_2016_18.JPG" alt="google_io_2016_18" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第5季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-5/"/>
    <updated>2016-04-28T00:08:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-5</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_5.png" alt="android_perf_patterns_season_5" /></p>

<blockquote><p>这是<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第5季的课程学习笔记，拖拖拉拉很久，记录分享给大家，请多多包涵担待指正！文章共10个段落，涉及的内容有：多线程并发的性能问题，介绍了AsyncTask，HandlerThread，IntentService与ThreadPool分别适合的使用场景以及各自的使用注意事项，这是一篇了解Android多线程编程不可多得的基础文章，清楚的了解这些Android系统提供的多线程基础组件之间的差异以及优缺点，才能够在项目实战中做出最恰当的选择。</p></blockquote>

<h2>1)Threading Performance</h2>

<p>在程序开发的实践当中，为了让程序表现得更加流畅，我们肯定会需要使用到多线程来提升程序的并发执行性能。但是编写多线程并发的代码一直以来都是一个相对棘手的问题，所以想要获得更佳的程序性能，我们非常有必要掌握多线程并发编程的基础技能。</p>

<p>众所周知，Android程序的大多数代码操作都必须执行在主线程，例如系统事件(例如设备屏幕发生旋转)，输入事件(例如用户点击滑动等)，程序回调服务，UI绘制以及闹钟事件等等。那么我们在上述事件或者方法中插入的代码也将执行在主线程。</p>

<p><img src="/images/android_perf_5_threading_main_thread.png" alt="android_perf_5_threading_main_thread" /></p>

<!-- More -->


<p>一旦我们在主线程里面添加了操作复杂的代码，这些代码就很可能阻碍主线程去响应点击/滑动事件，阻碍主线程的UI绘制等等。我们知道，为了让屏幕的刷新帧率达到60fps，我们需要确保16ms内完成单次刷新的操作。一旦我们在主线程里面执行的任务过于繁重就可能导致接收到刷新信号的时候因为资源被占用而无法完成这次刷新操作，这样就会产生掉帧的现象，刷新帧率自然也就跟着下降了(一旦刷新帧率降到20fps左右，用户就可以明显感知到卡顿不流畅了)。</p>

<p><img src="/images/android_perf_5_threading_dropframe.png" alt="android_perf_5_threading_dropframe" /></p>

<p>为了避免上面提到的掉帧问题，我们需要使用多线程的技术方案，把那些操作复杂的任务移动到其他线程当中执行，这样就不容易阻塞主线程的操作，也就减小了出现掉帧的可能性。</p>

<p><img src="/images/android_perf_5_threading_workthread.png" alt="android_perf_5_threading_workthread" /></p>

<p>那么问题来了，为主线程减轻负的多线程方案有哪些呢？这些方案分别适合在什么场景下使用？Android系统为我们提供了若干组工具类来帮助解决这个问题。</p>

<ul>
<li><strong>AsyncTask</strong>: 为UI线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</li>
<li><strong>HandlerThread</strong>: 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</li>
<li><strong>ThreadPool</strong>: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</li>
<li><strong>IntentService</strong>: 适合于执行由UI触发的后台Service任务，并可以把后台任务执行的情况通过一定的机制反馈给UI。</li>
</ul>


<p>了解这些系统提供的多线程工具类分别适合在什么场景下，可以帮助我们选择合适的解决方案，避免出现不可预期的麻烦。虽然使用多线程可以提高程序的并发量，但是我们需要特别注意因为引入多线程而可能伴随而来的内存问题。举个例子，在Activity内部定义的一个AsyncTask，它属于一个内部类，该类本身和外面的Activity是有引用关系的，如果Activity要销毁的时候，AsyncTask还仍然在运行，这会导致Activity没有办法完全释放，从而引发内存泄漏。所以说，多线程是提升程序性能的有效手段之一，但是使用多线程却需要十分谨慎小心，如果不了解背后的执行机制以及使用的注意事项，很可能引起严重的问题。</p>

<h2>2)Understanding Android Threading</h2>

<p>通常来说，一个线程需要经历三个生命阶段：开始，执行，结束。线程会在任务执行完毕之后结束，那么为了确保线程的存活，我们会在执行阶段给线程赋予不同的任务，然后在里面添加退出的条件从而确保任务能够执行完毕后退出。</p>

<p><img src="/images/android_perf_5_thread_lifecycle.png" alt="android_perf_5_thread_lifecycle" /></p>

<p>在很多时候，线程不仅仅是线性执行一系列的任务就结束那么简单的，我们会需要增加一个任务队列，让线程不断的从任务队列中获取任务去进行执行，另外我们还可能在线程执行的任务过程中与其他的线程进行协作。如果这些细节都交给我们自己来处理，这将会是件极其繁琐又容易出错的事情。</p>

<p><img src="/images/android_perf_5_thread_thread.png" alt="android_perf_5_thread_thread" /></p>

<p>所幸的是，Android系统为我们提供了Looper，Handler，MessageQueue来帮助实现上面的线程任务模型：</p>

<p><strong>Looper</strong>: 能够确保线程持续存活并且可以不断的从任务队列中获取任务并进行执行。</p>

<p><img src="/images/android_perf_5_thread_looper.png" alt="android_perf_5_thread_looper" /></p>

<p><strong>Handler</strong>: 能够帮助实现队列任务的管理，不仅仅能够把任务插入到队列的头部，尾部，还可以按照一定的时间延迟来确保任务从队列中能够来得及被取消掉。</p>

<p><img src="/images/android_perf_5_thread_handler.png" alt="android_perf_5_thread_handler" /></p>

<p><strong>MessageQueue</strong>: 使用Intent，Message，Runnable作为任务的载体在不同的线程之间进行传递。</p>

<p><img src="/images/android_perf_5_thread_messagequeue.png" alt="android_perf_5_thread_messagequeue" /></p>

<p>把上面三个组件打包到一起进行协作，这就是<strong>HandlerThread</strong></p>

<p><img src="/images/android_perf_5_thread_handlerthread.png" alt="android_perf_5_thread_handlerthread" /></p>

<p>我们知道，当程序被启动，系统会帮忙创建进程以及相应的主线程，而这个主线程其实就是一个HandlerThread。这个主线程会需要处理系统事件，输入事件，系统回调的任务，UI绘制等等任务，为了避免主线程任务过重，我们就会需要不断的开启新的工作线程来处理那些子任务。</p>

<h2>3)Memory &amp; Threading</h2>

<p>增加并发的线程数会导致内存消耗的增加，平衡好这两者的关系是非常重要的。我们知道，多线程并发访问同一块内存区域有可能带来很多问题，例如读写的权限争夺问题，<a href="https://en.wikipedia.org/wiki/ABA_problem">ABA问题</a>等等。为了解决这些问题，我们会需要引入<strong>锁</strong>的概念。</p>

<p>在Android系统中也无法避免因为多线程的引入而导致出现诸如上文提到的种种问题。Android UI对象的创建，更新，销毁等等操作都默认是执行在主线程，但是如果我们在非主线程对UI对象进行操作，程序将可能出现异常甚至是崩溃。</p>

<p> <img src="/images/android_perf_5_memory_thread_update.png" alt="android_perf_5_memory_thread_update" /></p>

<p>另外，在非UI线程中直接持有UI对象的引用也很可能出现问题。例如Work线程中持有某个UI对象的引用，在Work线程执行完毕之前，UI对象在主线程中被从ViewHierarchy中移除了，这个时候UI对象的任何属性都已经不再可用了，另外对这个UI对象的更新操作也都没有任何意义了，因为它已经从ViewHierarchy中被移除，不再绘制到画面上了。</p>

<p><img src="/images/android_perf_5_memory_view_remove.png" alt="android_perf_5_memory_view_remove" /></p>

<p>不仅如此，View对象本身对所属的Activity是有引用关系的，如果工作线程持续保有View的引用，这就可能导致Activity无法完全释放。除了直接显式的引用关系可能导致内存泄露之外，我们还需要特别留意隐式的引用关系也可能导致泄露。例如通常我们会看到在Activity里面定义的一个AsyncTask，这种类型的AsyncTask与外部的Activity是存在隐式引用关系的，只要Task没有结束，引用关系就会一直存在，这很容易导致Activity的泄漏。更糟糕的情况是，它不仅仅发生了内存泄漏，还可能导致程序异常或者崩溃。</p>

<p><img src="/images/android_perf_5_memory_asynctask.png" alt="android_perf_5_memory_asynctask" /></p>

<p>为了解决上面的问题，我们需要谨记的原则就是：不要在任何非UI线程里面去持有UI对象的引用。系统为了确保所有的UI对象都只会被UI线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当Activity被销毁的时候，由该Activity所触发的非UI线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止UI对象被错误的使用。</p>

<h2>4)Good AsyncTask Hunting</h2>

<p>AsyncTask是一个让人既爱又恨的组件，它提供了一种简便的异步处理机制，但是它又同时引入了一些令人厌恶的麻烦。一旦对AsyncTask使用不当，很可能对程序的性能带来负面影响，同时还可能导致内存泄露。</p>

<p>举个例子，常遇到的一个典型的使用场景：用户切换到某个界面，触发了界面上的图片的加载操作，因为图片的加载相对来说耗时比较长，我们需要在子线程中处理图片的加载，当图片在子线程中处理完成之后，再把处理好的图片返回给主线程，交给UI更新到画面上。</p>

<p><img src="/images/android_perf_5_asynctask_main.png" alt="android_perf_5_asynctask_main" /></p>

<p>AsyncTask的出现就是为了快速的实现上面的使用场景，AsyncTask把在主线程里面的准备工作放到<code>onPreExecute()</code>方法里面进行执行，<code>doInBackground()</code>方法执行在工作线程中，用来处理那些繁重的任务，一旦任务执行完毕，就会调用<code>onPostExecute()</code>方法返回到主线程。</p>

<p><img src="/images/android_perf_5_asynctask_mode.png" alt="android_perf_5_asynctask_mode" /></p>

<p>使用AsyncTask需要注意的问题有哪些呢？请关注以下几点：</p>

<ul>
<li>首先，默认情况下，所有的AsyncTask任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。假设你按照顺序启动20个AsyncTask，一旦其中的某个AsyncTask执行时间过长，队列中的其他剩余AsyncTask都处于阻塞状态，必须等到该任务执行完毕之后才能够有机会执行下一个任务。情况如下图所示：</li>
</ul>


<p><img src="/images/android_perf_5_asynctask_single_queue.png" alt="android_perf_5_asynctask_single_queue" /></p>

<p>为了解决上面提到的线性队列等待的问题，我们可以使用<code>AsyncTask.executeOnExecutor()</code>强制指定AsyncTask使用线程池并发调度任务。</p>

<p><img src="/images/android_perf_5_asynctask_thread_pool.png" alt="android_perf_5_asynctask_thread_pool" /></p>

<ul>
<li>其次，如何才能够真正的取消一个AsyncTask的执行呢？我们知道AsyncTaks有提供<code>cancel()</code>的方法，但是这个方法实际上做了什么事情呢？线程本身并不具备中止正在执行的代码的能力，为了能够让一个线程更早的被销毁，我们需要在<code>doInBackground()</code>的代码中不断的添加程序是否被中止的判断逻辑，如下图所示：</li>
</ul>


<p><img src="/images/android_perf_5_asynctask_cancel.png" alt="android_perf_5_asynctask_cancel" /></p>

<p>一旦任务被成功中止，AsyncTask就不会继续调用<code>onPostExecute()</code>，而是通过调用<code>onCancelled()</code>的回调方法反馈任务执行取消的结果。我们可以根据任务回调到哪个方法（是onPostExecute还是onCancelled）来决定是对UI进行正常的更新还是把对应的任务所占用的内存进行销毁等。</p>

<ul>
<li>最后，使用AsyncTask很容易导致内存泄漏，一旦把AsyncTask写成Activity的内部类的形式就很容易因为AsyncTask生命周期的不确定而导致Activity发生泄漏。</li>
</ul>


<p><img src="/images/android_perf_5_memory_asynctask.png" alt="android_perf_5_memory_asynctask" /></p>

<p>综上所述，AsyncTask虽然提供了一种简单便捷的异步机制，但是我们还是很有必要特别关注到他的缺点，避免出现因为使用错误而导致的严重系统性能问题。</p>

<h2>5）Getting a HandlerThread</h2>

<p>大多数情况下，AsyncTask都能够满足多线程并发的场景需要（在工作线程执行任务并返回结果到主线程），但是它并不是万能的。例如打开相机之后的预览帧数据是通过<code>onPreviewFrame()</code>的方法进行回调的，<code>onPreviewFrame()</code>和<code>open()</code>相机的方法是执行在同一个线程的。</p>

<p><img src="/images/android_perf_5_handlerthread_camera_open.png" alt="android_perf_5_handlerthread_camera_open" /></p>

<p>如果这个回调方法执行在UI线程，那么在onPreviewFrame()里面将要执行的数据转换操作将和主线程的界面绘制，事件传递等操作争抢系统资源，这就有可能影响到主界面的表现性能。</p>

<p><img src="/images/android_perf_5_handlerthread_main_thread2.png" alt="android_perf_5_handlerthread_main_thread2" /></p>

<p>我们需要确保onPreviewFrame()执行在工作线程。如果使用AsyncTask，会因为AsyncTask默认的线性执行的特性(即使换成并发执行)会导致因为无法把任务及时传递给工作线程而导致任务在主线程中被延迟，直到工作线程空闲，才可以把任务切换到工作线程中进行执行。</p>

<p><img src="/images/android_perf_5_handlerthread_asynctask.png" alt="android_perf_5_handlerthread_asynctask" /></p>

<p>所以我们需要的是一个执行在工作线程，同时又能够处理队列中的复杂任务的功能，而HandlerThread的出现就是为了实现这个功能的，它组合了Handler，MessageQueue，Looper实现了一个长时间运行的线程，不断的从队列中获取任务进行执行的功能。</p>

<p><img src="/images/android_perf_5_handlerthread_outline.png" alt="android_perf_5_handlerthread_outline" /></p>

<p>回到刚才的处理相机回调数据的例子，使用HandlerThread我们可以把open()操作与onPreviewFrame()的操作执行在同一个线程，同时还避免了AsyncTask的弊端。如果需要在onPreviewFrame()里面更新UI，只需要调用runOnUiThread()方法把任务回调给主线程就够了。</p>

<p><img src="/images/android_perf_5_handlerthread_camera.png" alt="android_perf_5_handlerthread_camera" /></p>

<p>HandlerThread比较合适处理那些在工作线程执行，需要花费时间偏长的任务。我们只需要把任务发送给HandlerThread，然后就只需要等待任务执行结束的时候通知返回到主线程就好了。</p>

<p>另外很重要的一点是，一旦我们使用了HandlerThread，需要特别注意给HandlerThread设置不同的线程优先级，CPU会根据设置的不同线程优先级对所有的线程进行调度优化。</p>

<p><img src="/images/android_perf_5_handlerthread_priority.png" alt="android_perf_5_handlerthread_priority" /></p>

<p>掌握HandlerThread与AsyncTask之间的优缺点，可以帮助我们选择合适的方案。</p>

<h2>6）Swimming in Threadpools</h2>

<p>线程池适合用在把任务进行分解，并发进行执行的场景。通常来说，系统里面会针对不同的任务设置一个单独的守护线程用来专门处理这项任务。例如使用Networking Thread用来专门处理网络请求的操作，使用IO Thread用来专门处理系统的I\O操作。针对那些场景，这样设计是没有问题的，因为对应的任务单次执行的时间并不长而且可以是顺序执行的。但是这种专属的单线程并不能满足所有的情况，例如我们需要一次性decode 40张图片，每个线程需要执行4ms的时间，如果我们使用专属单线程的方案，所有图片执行完毕会需要花费160ms(40*4)，但是如果我们创建10个线程，每个线程执行4个任务，那么我们就只需要16ms就能够把所有的图片处理完毕。</p>

<p><img src="/images/android_perf_5_threadpool_1.png" alt="android_perf_5_threadpool_1" /></p>

<p>为了能够实现上面的线程池模型，系统为我们提供了<code>ThreadPoolExecutor</code>帮助类来简化实现，剩下需要做的就只是对任务进行分解就好了。</p>

<p><img src="/images/android_perf_5_threadpool_2.png" alt="android_perf_5_threadpool_2" /></p>

<p>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为CPU只能同时执行固定数量的线程数，一旦同时并发的线程数量超过CPU能够同时执行的阈值，CPU就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。</p>

<p><img src="/images/android_perf_5_threadpool_3.png" alt="android_perf_5_threadpool_3" /></p>

<p>一旦同时并发的线程数量达到一定的量级，这个时候CPU在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少64K+的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。</p>

<p><img src="/images/android_perf_5_threadpool_4.png" alt="android_perf_5_threadpool_4" /></p>

<p>另外需要关注的一个问题是：<code>Runtime.getRuntime().availableProcesser()</code>方法并不可靠，他返回的值并不是真实的CPU核心数，因为CPU会在某些情况下选择对部分核心进行睡眠处理，在这种情况下，返回的数量就只能是激活的CPU核心数。</p>

<h2>7）The Zen of IntentService</h2>

<p>默认的Service是执行在主线程的，可是通常情况下，这很容易影响到程序的绘制性能(抢占了主线程的资源)。除了前面介绍过的AsyncTask与HandlerThread，我们还可以选择使用IntentService来实现异步操作。IntentService继承自普通Service同时又在内部创建了一个HandlerThread，在<code>onHandlerIntent()</code>的回调里面处理扔到IntentService的任务。所以IntentService就不仅仅具备了异步线程的特性，还同时保留了Service不受主页面生命周期影响的特点。</p>

<p><img src="/images/android_perf_5_intentservice_outline.png" alt="android_perf_5_intentservice_outline" /></p>

<p>如此一来，我们可以在IntentService里面通过设置闹钟间隔性的触发异步任务，例如刷新数据，更新缓存的图片或者是分析用户操作行为等等，当然处理这些任务需要小心谨慎。</p>

<p>使用IntentService需要特别留意以下几点：</p>

<ul>
<li>首先，因为IntentService内置的是HandlerThread作为异步线程，所以每一个交给IntentService的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。</li>
<li>其次，通常使用到IntentService的时候，我们会结合使用BroadcastReceiver把工作线程的任务执行结果返回给主UI线程。使用广播容易引起性能问题，我们可以使用LocalBroadcastManager来发送只在程序内部传递的广播，从而提升广播的性能。我们也可以使用<code>runOnUiThread()</code>快速回调到主UI线程。</li>
<li>最后，包含正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li>
</ul>


<h2>8）Threading and Loaders</h2>

<p>当启动工作线程的Activity被销毁的时候，我们应该做点什么呢？为了方便的控制工作线程的启动与结束，Android为我们引入了Loader来解决这个问题。我们知道Activity有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在Activity不停的创建与销毁的过程当中，很有可能因为工作线程持有Activity的View而导致内存泄漏(因为工作线程很可能持有View的强引用，另外工作线程的生命周期还无法保证和Activity的生命周期一致，这样就容易发生内存泄漏了)。除了可能引起内存泄漏之外，在Activity被销毁之后，工作线程还继续更新视图是没有意义的，因为此时视图已经不在界面上显示了。</p>

<p><img src="/images/android_perf_5_loader_bad.png" alt="android_perf_5_loader_bad" /></p>

<p>Loader的出现就是为了确保工作线程能够和Activity的生命周期保持一致，同时避免出现前面提到的问题。</p>

<p><img src="/images/android_perf_5_loader_good.png" alt="android_perf_5_loader_good" /></p>

<p>LoaderManager会对查询的操作进行缓存，只要对应Cursor上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader可以直接把缓存的数据回调到<code>onLoadFinished()</code>，从而避免重新查询数据。另外系统会在Loader不再需要使用到的时候(例如使用Back按钮退出当前页面)回调<code>onLoaderReset()</code>方法，我们可以在这里做数据的清除等等操作。</p>

<p>在Activity或者Fragment中使用Loader可以方便的实现异步加载的框架，Loader有诸多优点。但是实现Loader的这套代码还是稍微有点点复杂，Android官方为我们提供了使用Loader的<a href="http://developer.android.com/intl/zh-cn/reference/android/content/AsyncTaskLoader.html">示例代码</a>进行参考学习。</p>

<h2>9）The Importance of Thread Priority</h2>

<p>理论上来说，我们的程序可以创建出非常多的子线程一起并发执行的，可是基于CPU时间片轮转调度的机制，不可能所有的线程都可以同时被调度执行，CPU需要根据线程的优先级赋予不同的时间片。</p>

<p><img src="/images/android_perf_5_threadpriority_CPU.png" alt="android_perf_5_threadpriority_CPU" /></p>

<p>Android系统会根据当前运行的可见的程序和不可见的后台程序对线程进行归类，划分为forground的那部分线程会大致占用掉CPU的90%左右的时间片，background的那部分线程就总共只能分享到5%-10%左右的时间片。之所以设计成这样是因为forground的程序本身的优先级就更高，理应得到更多的执行时间。</p>

<p><img src="/images/android_perf_5_threadpriority_90.png" alt="android_perf_5_threadpriority_90" /></p>

<p>默认情况下，新创建的线程的优先级默认和创建它的母线程保持一致。如果主UI线程创建出了几十个工作线程，这些工作线程的优先级就默认和主线程保持一致了，为了不让新创建的工作线程和主线程抢占CPU资源，需要把这些线程的优先级进行降低处理，这样才能给帮组CPU识别主次，提高主线程所能得到的系统资源。</p>

<p><img src="/images/android_perf_5_threadpriority_less.png" alt="android_perf_5_threadpriority_less" /></p>

<p>在Android系统里面，我们可以通过<code>android.os.Process.setThreadPriority(int)</code>设置线程的优先级，参数范围从-20到24，数值越小优先级越高。Android系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。</p>

<p><img src="/images/android_perf_5_threadpriority_const.png" alt="android_perf_5_threadpriority_const" /></p>

<p>大多数情况下，新创建的线程优先级会被设置为默认的0，主线程设置为0的时候，新创建的线程还可以利用<code>THREAD_PRIORITY_LESS_FAVORABLE</code>或者<code>THREAD_PRIORITY_MORE_FAVORABLE</code>来控制线程的优先级。</p>

<p><img src="/images/android_perf_5_threadpriority_value.png" alt="android_perf_5_threadpriority_value" /></p>

<p>Android系统里面的AsyncTask与IntentService已经默认帮助我们设置线程的优先级，但是对于那些非官方提供的多线程工具类，我们需要特别留意根据需要自己手动来设置线程的优先级。</p>

<p><img src="/images/android_perf_5_threadpriority_asynctask.png" alt="android_perf_5_threadpriority_asynctask" />
<img src="/images/android_perf_5_threadpriority_intentservice.png" alt="android_perf_5_threadpriority_intentservice" /></p>

<h2>10）Profile GPU Rendering : M Update</h2>

<p>从Android M系统开始，系统更新了GPU Profiling的工具来帮助我们定位UI的渲染性能问题。早期的CPU Profiling工具只能粗略的显示出Process，Execute，Update三大步骤的时间耗费情况。</p>

<p><img src="/images/android_perf_5_gpu_profiling_old.png" alt="android_perf_5_gpu_profiling_old" /></p>

<p>但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在Android M版本开始，GPU Profiling工具把渲染操作拆解成如下8个详细的步骤进行显示。</p>

<p><img src="/images/android_perf_5_gpu_profiling_8steps.png" alt="android_perf_5_gpu_profiling_8steps" /></p>

<p>旧版本中提到的Proces，Execute，Update还是继续得到了保留，他们的对应关系如下：</p>

<p><img src="/images/android_perf_5_gpu_profiling_3steps.png" alt="android_perf_5_gpu_profiling_3steps" /></p>

<p>接下去我们看下其他五个步骤分别代表了什么含义：</p>

<ul>
<li><strong>Sync &amp; Upload</strong>：通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。</li>
<li><strong>Measure &amp; Layout</strong>：这里表示的是布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。</li>
<li><strong>Animation</strong>：表示的是计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。</li>
<li><strong>Input Handling</strong>：表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。</li>
<li><strong>Misc/Vsync Delay</strong>：如果稍加注意，我们可以在开发应用的Log日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况。</li>
</ul>


<!-- ![android_perf_5_gpu_profiling_sync_upload](/images/android_perf_5_gpu_profiling_sync_upload.png) -->


<!-- ![android_perf_5_gpu_profiling_vsync](/images/android_perf_5_gpu_profiling_vsync.png)
 -->


<!-- ![android_perf_5_gpu_profiling_measure](/images/android_perf_5_gpu_profiling_measure.png) -->


<p>上面八种不同的颜色区分了不同的操作所耗费的时间，为了便于我们迅速找出那些有问题的步骤，GPU Profiling工具会显示16ms的阈值线，这样就很容易找出那些不合理的性能问题，再仔细看对应具体哪个步骤相对来说耗费时间比例更大，结合上面介绍的细化步骤，从而快速定位问题，修复问题。</p>

<hr />

<p>首发于CSDN：<a href="http://ms.csdn.net/geek/71031">Android性能优化典范（五）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第4季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-4/"/>
    <updated>2015-12-31T23:39:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-4</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_4.png" alt="android_perf_patterns_season_4" /></p>

<blockquote><p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>第4季的课程学习笔记终于在2015年的最后一天完成了，文章共17个段落，包含的内容大致有：优化网络请求的行为，优化安装包的资源文件，优化数据传输的效率，性能优化的几大基础原理等等。因为学习认知水平有限，肯定存在不少理解偏差甚至错误的地方，请多多交流指正！</p></blockquote>

<h2>1)Cachematters for networking</h2>

<p>想要使得Android系统上的网络访问操作更加的高效就必须做好网络数据的缓存。这是提高网络访问性能最基础的步骤之一。从手机的缓存中直接读取数据肯定比从网络上获取数据要更加的便捷高效，特别是对于那些会被频繁访问到的数据，需要把这些数据缓存到设备上，以便更加快速的进行访问。</p>

<p>Android系统上关于网络请求的Http Response Cache是默认关闭的，这样会导致每次即使请求的数据内容是一样的也会需要重复被调用执行，效率低下。我们可以通过下面的代码示例开启<a href="http://developer.android.com/reference/android/net/http/HttpResponseCache.html">HttpResponseCache</a>。</p>

<!-- More -->


<p><img src="/images/android_perf_4_network_cache_enable.png" alt="android_perf_4_network_cache_enable" /></p>

<p>开启Http Response Cache之后，Http操作相关的返回数据就会缓存到文件系统上，不仅仅是主程序自己编写的网络请求相关的数据会被缓存，另外引入的library库中的网络相关的请求数据也会被缓存到这个Cache中。</p>

<p>网络请求的场景有可以是普通的http请求，也可以打开某个URL去获取数据，如下图所示：</p>

<p><img src="/images/android_perf_4_network_cache_code.png" alt="android_perf_4_network_cache_code" /></p>

<p>我们有两种方式来清除<code>HttpResponseCache</code>的缓存数据：第一种方式是缓存溢出的时候删除最旧最老的文件，第二种方式是通过Http返回Header中的<code>Cache-Control</code>字段来进行控制的。如下图所示：</p>

<p><img src="/images/android_perf_4_network_cache_control.png" alt="android_perf_4_network_cache_control" /></p>

<p>通常来说，<code>HttpResponseCache</code>会缓存所有的返回信息，包括实际的数据与Header的部分.一般情况下，这个Cache会自动根据协议返回<code>Cache-Control</code>的内容与当前缓存的数据量来决定哪些数据应该继续保留，哪些数据应该删除。但是在一些极端的情况下，例如服务器返回的数据没有设置Cache废弃的时间，或者是本地的Cache文件系统与返回的缓存数据有冲突，或者是某些特殊的网络环境导致HttpResponseCache工作异常，在这些情况下就需要我们自己来实现Http的缓存Cache。</p>

<p>实现自定义的http缓存，需要解决两个问题：第一个是实现一个DiskCacheManager，另外一个是制定Cache的缓存策略。关于DiskCacheManager，我们可以扩展Android系统提供的<a href="https://developer.android.com/intl/zh-cn/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html">DiskLruCache</a>来实现。而Cache的缓存策略，相对来说复杂一些，我们可能需要把部分JSON数据设计成不能缓存的，另外一些JSON数据设计成可以缓存几天的，把缩略图设计成缓存一两天的等等，为不同的数据类型根据他们的使用特点制定不同的缓存策略。</p>

<p><img src="/images/android_perf_4_network_cache_diff.png" alt="android_perf_4_network_cache_diff" /></p>

<p>想要比较好的实现这两件事情，如果全部自己从头开始写会比较繁琐复杂，所幸的是，有不少著名的开源框架帮助我们快速的解决了那些问题。我们可以使用<a href="https://developer.android.com/training/volley/index.html">Volly</a>，<a href="http://square.github.io/okhttp/">okHTTP</a>，<a href="http://square.github.io/picasso/">Picasso</a>来实现网络缓存。</p>

<p>实现好网络缓存之后，我们可以使用Android Studio里面的<code>Network Traffic Tools</code>来查看网络数据的请求与返回情况，另外我们还可以使用<a href="https://developer.att.com/application-resource-optimizer">AT&amp;T ARO</a>工具来抓取网络数据包进行分析查看。</p>

<h2>2)Optimizing Network Request Frequencies</h2>

<p>应用程序的一个基础功能是能够保持确保界面上呈现的信息是即时最新的，例如呈现最新的新闻，天气，信息流等等信息。但是，过于频繁的促使手机客户端应用去同步最新的服务器数据会对性能产生很大的负面影响，不仅仅使得CPU不停的在工作，内存，网络流量，电量等等都会持续的被消耗，所以在进行网络请求操作的时候一定要避免多度同步操作。</p>

<p>退到后台的应用为了能够在切换回前台的时候呈现最新的数据，会偷偷在后台不停的做同步的操作。这种行为会带来很严重的问题，首先因为网络请求的行为异常的耗电，其次不停的进行网络同步会耗费很多带宽流量。</p>

<p>为了能够尽量的减少不必要的同步操作，我们需要遵守下面的一些规则：</p>

<ul>
<li>首先我们要对网络行为进行分类，区分需要立即更新数据的行为和其他可以进行延迟的更新行为，为不同的场景进行差异化处理。</li>
<li>其次要避免客户端对服务器的轮询操作，这样会浪费很多的电量与带宽流量。解决这个问题，我们可以使用Google Cloud Message来对更新的数据进行推送。</li>
<li>然后在某些必须做同步的场景下，需要避免使用固定的间隔频率来进行更新操作，我们应该在返回的数据无更新的时候，使用双倍的间隔时间来进行下一次同步。</li>
<li>最后更进一步，我们还可以通过判断当前设备的状态来决定同步的频率，例如判断设备处于休眠，运动等不同的状态设计各自不同时间间隔的同步频率。</li>
</ul>


<p><img src="/images/android_perf_4_network_frequencies_backoff.png" alt="android_perf_4_network_frequencies_backoff" /></p>

<p>另外，我们还可以通过判断设备是否连接上WiFi，是否正在充电来决定更新的频率。为了能够方便的实现这个功能，Android为我们提供了<a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmNetworkManager">GCMNetworkManager</a>来判断设备当下的状态，从而设计更加高效的网络同步操作，如下图所示：</p>

<p><img src="/images/android_perf_4_network_frequencies_gcm.png" alt="android_perf_4_network_frequencies_gcm" /></p>

<h2>3)Effective Prefetching</h2>

<p>关于提升网络操作的性能，除了避免频繁的网络同步操作之外，还可以使用捆绑批量访问的方式来减少访问的频率，为了达到这个目的，我们就需要了解Prefetching。</p>

<p>举个例子，在某个场景下，一开始发出了网络请求得到了某张图片，隔了10s之后，发出第二次请求想要拿到另外一张图片，再隔了6s发出第三张图片的网络请求。这会导致设备的无线蜂窝一直处于高消耗的状态。Prefetching就是预先判定那些可能马上就会使用到的网络资源，捆绑一起集中进行网络请求。这样能够极大的减少电量的消耗，提升设备的续航时间。</p>

<p><img src="/images/android_perf_4_prefetching_bundle.png" alt="android_perf_4_prefetching_bundle" /></p>

<p>使用Prefetching的难点在于如何判断事先获取的数据量到底是多少，如果预取的数据量偏少，那么就起不到什么效果，但是如果预取过多，又可能导致访问的时间过长。</p>

<p><img src="/images/android_perf_4_prefetching_tricky.png" alt="android_perf_4_prefetching_tricky" /></p>

<p>那么问题来了，到底预取多少才比较合适呢？一个比较普适的规则是，在3G网络下可以预取1-5Mb的数据量，或者是按照提前预期后续1-2分钟的数据作为基线标准。在实际的操作当中，我们还需要考虑当前的网络速度来决定预取的数据量，例如在同样的时间下，4G网络可以获取到12张图片的数据，而2G网络则只能拿到3张图片的数据。所以，我们还需要把当前的网络环境情况添加到设计预取数据量的策略当中去。判断当前设备的状态与网络情况，可以使用前面提到过的<a href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GcmNetworkManager">GCMNetworkManager</a>。</p>

<h2>4)Adapting to Latency</h2>

<p>网络延迟通常来说很容易被用户察觉到，严重的网络延迟会对用户体验造成很大的影响，用户很容易抱怨应用程序写的不好。</p>

<p>一个典型的网络操作行为，通常包含以下几个步骤：首先手机端发起网络请求，到达网络服务运营商的基站，再转移到服务提供者的服务器上，经过解码之后，接着访问本地的存储数据库，获取到数据之后，进行编码，最后按照原来传递的路径逐层返回。如下图所示：</p>

<p><img src="/images/android_perf_4_network_latency.png" alt="android_perf_4_network_latency" /></p>

<p>在上面的网络请求链路当中的任何一个环节都有可能导致严重的延迟，成为性能瓶颈，但是这些环节可能出现的问题，客户端应用是无法进行调节控制的，应用能够做的就只是根据当前的网络环境选择当下最佳的策略来降低出现网络延迟的概率。主要的实施步骤有两步：第1步检测收集当前的网络环境信息，第2步根据当前收集到的信息进行网络请求行为的调整。</p>

<p>关于第1步检测当前的网络环境，我们可以使用系统提供的API来获取到相关的信息，如下图所示：</p>

<p><img src="/images/android_perf_4_network_latency_detect.png" alt="android_perf_4_network_latency_detect" /></p>

<p>通过上面的示例，我们可以获取到移动网络的详细子类型，例如4G(LTE),3G等等，详细分类见下图，获取到详细的移动网络类型之后，我们可以根据当前网络的速率来调整网络请求的行为：</p>

<p><img src="/images/android_perf_4_network_latency_subtype.png" alt="android_perf_4_network_latency_subtype" /></p>

<p>关于第2步根据收集到的信息进行策略的调整，通常来说，我们可以把网络请求延迟划分为三档：例如把网络延迟小于60ms的划分为GOOD，大于220ms的划分为BAD，介于两者之间的划分为OK（这里的60ms，220ms会需要根据不同的场景提前进行预算推测）。如果网络延迟属于GOOD的范畴，我们就可以做更多比较激进的预取数据的操作，如果网络延迟属于BAD的范畴，我们就应该考虑把当下的网络请求操作Hold住等待网络状况恢复到GOOD的状态再进行处理。</p>

<p><img src="/images/android_perf_4_network_latency_three_category.png" alt="android_perf_4_network_latency_three_category" /></p>

<p>前面提到说60ms，220ms是需要提前自己预测的，可是预测的工作相当复杂。首先针对不同的机器与网络环境，网络延迟的三档阈值都不太一样，出现的概率也不尽相同，我们会需要针对这些不同的用户与设备选择不同的阈值进行差异化处理：</p>

<p><img src="/images/android_perf_4_network_latency_three_level.png" alt="android_perf_4_network_latency_three_level" /></p>

<p>Android官方为了帮助我们设计自己的网络请求策略，为我们提供了模拟器的网络流量控制功能来对实际环境进行模拟测量，或者还可以使用AT&amp;T提供的<a href="http://developer.att.com/developer/legalAgreementPage.jsp?passedItemId=14500040">AT&amp;T Network Attenuator</a>来帮助预估网络延迟。</p>

<h2>5)Minimizing Asset Payload</h2>

<p>为了能够减小网络传输的数据量，我们需要对传输的数据做压缩的处理，这样能够提高网络操作的性能。首先不同的网络环境，下载速度以及网络延迟是存在差异的，如下图所示：</p>

<p><img src="/images/android_perf_4_min_asset_load.png" alt="android_perf_4_min_asset_load" /></p>

<p>如果我们选择在网速更低的网络环境下进行数据传输，这就意味着需要执行更长的时间，而更长的网络操作行为，会导致电量消耗更加严重。另外传输的数据如果不做压缩处理，也同样会增加网络传输的时间，消耗更多的电量。不仅如此，未经过压缩的数据，也会消耗更多的流量，使得用户需要付出更多的流量费。</p>

<p>通常来说，网络传输数据量的大小主要由两部分组成：图片与序列化的数据，那么我们需要做的就是减少这两部分的数据传输大小，分下面两个方面来讨论。</p>

<ul>
<li>A)首先需要做的是减少图片的大小，选择合适的图片保存格式是第一步。下图展示了PNG,JPEG,WEBP三种主流格式在占用空间与图片质量之间的对比：</li>
</ul>


<p><img src="/images/android_perf_4_min_asset_png_jpeg_webp.png" alt="android_perf_4_min_asset_png_jpeg_webp" /></p>

<p>对于JPEG与WEBP格式的图片，不同的清晰度对占用空间的大小也会产生很大的影响，适当的减少JPG Quality，可以大大的缩小图片占用的空间大小。</p>

<p>另外，我们需要为不同的使用场景提供当前场景下最合适的图片大小，例如针对全屏显示的情况我们会需要一张清晰度比较高的图片，而如果只是显示为缩略图的形式，就只需要服务器提供一个相对清晰度低很多的图片即可。服务器应该支持到为不同的使用场景分别准备多套清晰度不一样的图片，以便在对应的场景下能够获取到最适合自己的图片。这虽然会增加服务端的工作量，可是这个付出却十分值得！</p>

<ul>
<li>B)其次需要做的是减少序列化数据的大小。JSON与XML为了提高可读性，在文件中加入了大量的符号，空格等等字符，而这些字符对于程序来说是没有任何意义的。我们应该使用Protocal Buffers，Nano-Proto-Buffers，FlatBuffer来减小序列化的数据的大小。</li>
</ul>


<p>Android系统为我们提供了工具来查看网络传输的数据情况，打开Android Studio的Monitor，里面有网络访问的模块。或者是打开AT&amp;T提供的<a href="https://developer.att.com/application-resource-optimizer">ARO</a>工具来查看网络请求状态。</p>

<h2>6)Service Performance Patterns</h2>

<p>Service是Android程序里面最常用的基础组件之一，但是使用Service很容易引起电量的过度消耗以及系统资源的未及时释放。学会在何时启用Service以及使用何种方式杀掉Service就显得十分有必要了。</p>

<p>简要过一下Service的特性：Service和UI没有关联，Service的创建，执行，销毁Service都是需要占用系统时间和内存的。另外Service是默认运行在UI线程的，这意味着Service可能会影响到系统的流畅度。</p>

<p>使用Service应该遵循下面的一些规则：</p>

<ul>
<li>避免错误的使用Service，例如我们不应该使用Service来监听某些事件的变化，不应该搞一个Service在后台对服务器不断的进行轮询(应该使用Google Cloud Messaging)</li>
<li>如果已经事先知道Service里面的任务应该执行在后台线程(非默认的主线程)的时候，我们应该使用IntentService或者结合HanderThread，AsycnTask Loader实现的Service。</li>
</ul>


<p>Android系统为我们提供了以下的一些异步相关的工具类</p>

<ul>
<li>GCM</li>
<li>BroadcastReciever</li>
<li>LocalBroadcastReciever</li>
<li>WakefulBroadcastReciver</li>
<li>HandlerThreads</li>
<li>AsyncTaskLoaders</li>
<li>IntentService</li>
</ul>


<p>如果使用上面的诸多方案还是无法替代普通的Service，那么需要注意的就是如何正确的关闭Service。</p>

<ul>
<li>普通的Started Service，需要通过stopSelf()来停止Service</li>
</ul>


<p><img src="/images/android_perf_4_service_started.png" alt="android_perf_4_service_started" /></p>

<ul>
<li>另外一种Bound Service，会在其他组件都unBind之后自动关闭自己</li>
</ul>


<p><img src="/images/android_perf_4_service_bound.png" alt="android_perf_4_service_bound" /></p>

<p>把上面两种Service进行合并之后，我们可以得到如下图所示的Service(相关知识，还可以参考<a href="http://hukai.me/android-notes-services/">http://hukai.me/android-notes-services/</a>, <a href="http://hukai.me/android-notes-bound-services/">http://hukai.me/android-notes-bound-services/</a>)</p>

<p><img src="/images/android_perf_4_service_mix.png" alt="android_perf_4_service_mix" /></p>

<h2>7)Removing unused code</h2>

<p>使用第三方库(library)可以在不用自己编写大量代码的前提下帮助我们解决一些难题，节约大量的时间，但是这些引入的第三方库很可能会导致主程序代码臃肿冗余。</p>

<p>如果我们处在人力，财力都相对匮乏的情况下，通常会倾向大量使用第三方库来帮助编写应用程序。这其实是无可厚非的，那些著名的第三方库的可行性早就被很多应用所采用并实践证明过。但是这里面存在的问题是，如果我们因为只需要某个library的一小部分功能而把整个library都导入自己的项目，这就会引起代码臃肿。一旦发生代码臃肿，用户就会下载到安装包偏大的应用程序，另外因为代码臃肿，还很有可能会超过单个编译文件只能有65536个方法的上限。解决这个问题的办法是使用<strong>MultiDex</strong>的方案，可是这实在是无奈之举，原则上，我们还是应该尽量避免出现这种情况。</p>

<p>Android为我们提供了Proguard的工具来帮助应用程序对代码进行瘦身，优化，混淆的处理。它会帮助移除那些没有使用到的代码，还可以对类名，方法名进行混淆处理以避免程序被反编译。举个例子，Google I/O 2015这个应用使用了大量的library，没有经过Proguard处理之前编译出来的包是8.4Mb大小，经过处理之后的包仅仅是4.1Mb大小。</p>

<p>使用Proguard相当的简单，只需要在build.gradle文件中配置minifEnable为true即可，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_code_proguard.png" alt="android_perf_4_remove_unused_code_proguard" /></p>

<p>但是Proguard还是不足够聪明到能够判断哪些类，哪些方法是不能够被混淆的，针对这些情况，我们需要手动的把这些需要保留的类名与方法名添加到Proguard的配置文件中，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_code_proguard_setting.png" alt="android_perf_4_remove_unused_code_proguard_setting" /></p>

<p>在使用library的时候，需要特别注意这些library在proguard配置上的说明文档，我们需要把这些配置信息添加到自己的主项目中。关于Proguard的详细说明，请看官方文档<a href="http://developer.android.com/tools/help/proguard.html">http://developer.android.com/tools/help/proguard.html</a></p>

<h2>8)Removing unused resources</h2>

<p>减少APK安装包的大小也是Android程序优化中很重要的一个方面，我们不应该给用户下载到一个臃肿的安装包。假设这样一个场景，我们引入了Google Play Service的library，是想要使用里面的Maps的功能，但是里面的登入等等其他功能是不需要的，可是这些功能相关的代码与图片资源，布局资源如果也被引入我们的项目，这样就会导致我们的程序安装包臃肿。</p>

<p>所幸的是，我们可以使用Gradle来帮助我们分析代码，分析引用的资源，对于那些没有被引用到的资源，会在编译阶段被排除在APK安装包之外，要实现这个功能，对我们来说仅仅只需要在build.gradle文件中配置shrinkResource为true就好了，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_resource.png" alt="android_perf_4_remove_unused_resource" /></p>

<p>为了辅助gradle对资源进行瘦身，或者是某些时候的特殊需要，我们可以通过tools:keep或者是tools:discard标签来实现对特定资源的保留与废弃，如下图所示：</p>

<p><img src="/images/android_perf_4_remove_unused_resource_tools.png" alt="android_perf_4_remove_unused_resource_tools" /></p>

<p>Gradle目前无法对values，drawable等根据运行时来决定使用的资源进行优化，对于这些资源，需要我们自己来确保资源不会有冗余。</p>

<h2>9)Perf Theory: Caching</h2>

<p>当我们讨论性能优化的时候，缓存是最常见最有效的策略之一。无论是为了提高CPU的计算速度还是提高数据的访问速度，在绝大多数的场景下，我们都会使用到缓存。关于缓存是如何提高效率的，这里就不赘述了。</p>

<p>那么在什么地方，在何时应该利用好缓存来提高效率呢？请看下面的例子，很明显的演示了在某些细节上是如何利用缓存的原理来提高代码的执行效率的：</p>

<p><img src="/images/android_perf_4_cache_1.png" alt="android_perf_4_cache_1" />
<img src="/images/android_perf_4_cache_2.png" alt="android_perf_4_cache_2" /></p>

<p>类似上面的例子采用缓存原理的地方还有很多，例如缓存到内存里面的图片资源，网络请求返回数据的缓存等等。总之，使用缓存就是为了减少不必要的操作，尽量复用已有的对象来提高效率。</p>

<h2>10)Perf Theory: Approximation(近似法)</h2>

<p>很多时候，我们都需要学会在性能更优与体验更好之间做一定的权衡取舍。为了获取更好的表现性能，我们可能会需要牺牲一些用户体验，例如把某些细节做删除或者是降级处理以便有更好的性能。例如，导航类的应用，如果在导航期间是不停的执行定位的操作，这样能够很及时的获取到最新的位置信息以及当下位置相关的其他提示信息，但是这样会导致网络流量以及手机电量的过度消耗。所以我们可以做一定的降级处理，每隔固定的一段时间才去获取一次位置信息，损失一点及时性来换取更长的续航时间。</p>

<p>还有很多地方都会用到近似法则来优化程序的性能，例如使用一张比较接近实际大小的图片来替代原图，换取更快的加载速度。所以对于那些对计算结果要求不需要十分精确的场景，我们可以使用近似法则来提高程序的性能。</p>

<h2>11)Perf Theory: Culling(遴选，挑选)</h2>

<p>在以前的性能优化课程里面，我们知道可以通过减少Overdraw来提高程序的渲染性能（主要手段有移除非必须的background，减少重叠的布局，使用clipRect来提高自定义View的绘制性能），今天在这里要介绍的另外一个提高性能的方法是逐步对数据进行过滤筛选，减小搜索的数据集，以此提高程序的执行性能。例如我们需要搜索到居住在某个地方，年龄是多少，符合某些特定条件的候选人，就可以通过逐层过滤筛选的方式来提高后续搜索的执行效率。</p>

<h2>12)Perf Theory: Threading</h2>

<p>使用多线程并发处理任务，从某种程度上可以快速提高程序的执行性能。对于Android程序来说，主线程通常也成为UI线程，需要处理UI的渲染，响应用户的操作等等。对于那些可能影响到UI线程的任务都需要特别留意是否有必要放到其他的线程来进行处理。如果处理不当，很有可能引起程序ANR。关于多线程的使用建议，可以参考官方的培训课程<a href="http://developer.android.com/training/best-background.html">http://developer.android.com/training/best-background.html</a></p>

<h2>13)Perf Theory: Batching</h2>

<p>关于Batching，在前几季的性能优化课程里面也不止一次提到，下面使用一张图演示下Batching的原理：</p>

<p><img src="/images/android_perf_4_batching.png" alt="android_perf_4_batching" /></p>

<p>网络请求的批量执行是另外一个比较适合说明batching使用场景的例子，因为每次发起网络请求都相对来说比较耗时耗电，如果能够做到批量一起执行，可以大大的减少电量的消耗。</p>

<p><img src="/images/android_perf_4_batching_network.png" alt="android_perf_4_batching_network" /></p>

<h2>14)Serialization performance</h2>

<p>数据的序列化是程序代码里面必不可少的组成部分，当我们讨论到数据序列化的性能的时候，需要了解有哪些候选的方案，他们各自的优缺点是什么。首先什么是序列化？用下面的图来解释一下：</p>

<p><img src="/images/android_perf_4_serialIzation.png" alt="android_perf_4_serialIzation" /></p>

<p>数据序列化的行为可能发生在数据传递过程中的任何阶段，例如网络传输，不同进程间数据传递，不同类之间的参数传递，把数据存储到磁盘上等等。通常情况下，我们会把那些需要序列化的类实现Serializable接口(如下图所示)，但是这种传统的做法效率不高，实施的过程会消耗更多的内存。</p>

<p><img src="/images/android_perf_4_serialIzation_implement.png" alt="android_perf_4_serialIzation_implement" /></p>

<p>但是我们如果使用GSON库来处理这个序列化的问题，不仅仅执行速度更快，内存的使用效率也更高。Android的XML布局文件会在编译的阶段被转换成更加复杂的格式，具备更加高效的执行性能与更高的内存使用效率。</p>

<p><img src="/images/android_perf_4_serialIzation_gson.png" alt="android_perf_4_serialIzation_gson" /></p>

<p>下面介绍三个数据序列化的候选方案：</p>

<ul>
<li><strong><a href="https://developers.google.com/protocol-buffers/?utm_campaign=android_series_serialization_performance_101315&amp;utm_source=anddev&amp;utm_medium=yt-annt">Protocal Buffers</a></strong>：强大，灵活，但是对内存的消耗会比较大，并不是移动终端上的最佳选择。</li>
<li><strong><a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt?utm_campaign=android_series_serialization_performance_101315&amp;utm_source=anddev&amp;utm_medium=yt-annt">Nano-Proto-Buffers</a></strong>：基于Protocal，为移动终端做了特殊的优化，代码执行效率更高，内存使用效率更佳。</li>
<li><strong><a href="https://google.github.io/flatbuffers/">FlatBuffers</a></strong>：这个开源库最开始是由Google研发的，专注于提供更优秀的性能。</li>
</ul>


<p>上面这些方案在性能方面的数据对比如下图所示：</p>

<p><img src="/images/android_perf_4_serialIzation_filesize.png" alt="android_perf_4_serialIzation_filesize" />
<img src="/images/android_perf_4_serialIzation_encode.png" alt="android_perf_4_serialIzation_encode" /></p>

<p>为了避免序列化带来的性能问题，我们其实可以考虑使用SharedPreference或者SQLite来存储那些数据，避免需要先把那些复杂的数据进行序列化的操作。</p>

<h2>15)Smaller Serialized Data</h2>

<p>数据呈现的顺序以及结构会对序列化之后的空间产生不小的影响。通常来说，一般的数据序列化的过程如下图所示：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json.png" alt="android_perf_4_serialIzation_java_2_json" /></p>

<p>上面的过程，存在两个弊端，第一个是重复的属性名称：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json_dup.png" alt="android_perf_4_serialIzation_java_2_json_dup" /></p>

<p>另外一个是GZIP没有办法对上面的数据进行更加有效的压缩，假如相似数据间隔了32k的数据量，这样GZIP就无法进行更加有效的压缩：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json_gzip.png" alt="android_perf_4_serialIzation_java_2_json_gzip" /></p>

<p>但是我们稍微改变下数据的记录方式，就可以得到占用空间更小的数据，如下图所示：</p>

<p><img src="/images/android_perf_4_serialIzation_java_2_json2.png" alt="android_perf_4_serialIzation_java_2_json2" /></p>

<p>通过优化，至少有三方面的性能提升，如下图所示：</p>

<p>1）减少了重复的属性名：</p>

<p><img src="/images/android_perf_4_serialIzation_opt_1.png" alt="android_perf_4_serialIzation_opt_1" /></p>

<p>2）使得GZIP的压缩效率更高：</p>

<p><img src="/images/android_perf_4_serialIzation_opt_2.png" alt="android_perf_4_serialIzation_opt_2" /></p>

<p>3）同样的数据类型可以批量优化：</p>

<p><img src="/images/android_perf_4_serialIzation_opt_3.png" alt="android_perf_4_serialIzation_opt_3" /></p>

<h2>16)Caching UI data</h2>

<p>如今绝大多数的应用界面上呈现的数据都依赖于网络请求返回的结果，如何做到在网络数据返回之前避免呈现一个空白的等待页面呢（当然这里说的是非首次冷启动的情况）？这就会涉及到如何缓存UI界面上的数据。</p>

<p>缓存UI界面上的数据，可以采用方案有存储到文件系统，Preference，SQLite等等，做了缓存之后，这样就可以在请求数据返回结果之前，呈现给用户旧的数据，而不是使用正在加载的方式让用户什么数据都看不到，当然在请求网络最新数据的过程中，需要有正在刷新的提示。至于到底选择哪个方案来对数据进行缓存，就需要根据具体情况来做选择了。</p>

<h2>17)CPU Frequency Scaling</h2>

<p>调节CPU的频率会执行的性能产生较大的影响，为了最大化的延长设备的续航时间，系统会动态调整CPU的频率，频率越高执行代码的速度自然就越快。</p>

<p><img src="/images/android_perf_4_CPU.png" alt="android_perf_4_CPU" /></p>

<p>Android系统会在电量消耗与表现性能之间不断的做权衡，当有需要的时候会迅速调整CPU的频率到一个比较高负荷的状态，当程序不需要高性能的时候就会降低频率来确保更长的续航时间。</p>

<p><img src="/images/android_perf_4_CPU_adjust.png" alt="android_perf_4_CPU_adjust" /></p>

<p>Android系统检测到需要调整CPU的频率到CPU频率真的达到对应频率会需要花费大概20ms的时间，在此期间很有可能会因为CPU频率不够而导致代码执行偏慢。</p>

<p><img src="/images/android_perf_4_CPU_gap.png" alt="android_perf_4_CPU_gap" /></p>

<p>我们可以使用Systrace工具来导出CPU的执行情况，以便帮助定位性能问题。</p>

<hr />

<p>首发于CSDN：<a href="http://geek.csdn.net/news/detail/50692">Android性能优化典范（四）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android开发最佳实践]]></title>
    <link href="http://hukai.me/android-dev-patterns/"/>
    <updated>2015-10-02T15:38:00+08:00</updated>
    <id>http://hukai.me/android-dev-patterns</id>
    <content type="html"><![CDATA[<p><img src="/images/android_dev_patterns_logo.png" alt="android_dev_patterns_logo" /></p>

<blockquote><p>前段时间，Google公布了<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc-lJo_RGGXL2Psr8vVCTWjM">Android开发最佳实践</a>的一系列课程，涉及到一些平时开发过程中应该保持的良好习惯以及如何使用最新的<a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">Android Design Support Library</a>来快速实现官方推荐的Material Design样式的应用。下面是个人的学习摘要总结，不对的地方请多多交流指点，谢谢！</p></blockquote>

<h2>1）注意对隐式Intent的运行时检查保护</h2>

<p>类似打开相机，发送图片等隐式Intent，是并不一定能够在所有的Android设备上都正常运行。例如打开相机的隐式Intent，如果系统相机应用被关闭或者不存在相机应用，又或者是相机应用的某些权限被关闭等等情况都可能导致这个隐式的Intent无法正常工作。一旦发生隐式Intent找不到合适的调用组件的情况，系统就会抛出<code>ActivityNotFoundException</code>的异常，如果我们的应用没有对这个异常做任何处理，那应用就会发生Crash。</p>

<p>预防这个问题的最佳解决方案是在发出这个隐式Intent之前调用<code>resolveActivity</code>做检查，关于这个API的解释以及用法如下：</p>

<!-- More -->


<p><img src="/images/android_dev_patterns_implicit_intent.png" alt="android_dev_patterns_implicit_intent" /></p>

<p>然后这个API的使用范例如下：</p>

<p>```java
Intent intent = new Intent(Intent.ACTION_XXX);
ComponentName componentName = intent.resolveActivity(getPackageManager());
if(componentName != null) {</p>

<pre><code>String className = componentName.getClassName();
</code></pre>

<p>}
```</p>

<h2>2）使用NotificationCompat兼容包来处理消息通知</h2>

<p>为了解决Android系统版本差异导致的Notification兼容性问题，Android官方提供了<code>NotificationCompat</code>兼容类来帮助开发实现体验统一的Notification。通常来说，建立一个Notification至少会有三种元素：图标，标题，文本。我们通常会使用如下的代码来实现一个基础的Notification功能：</p>

<p><img src="/images/android_dev_patterns_notification_base.png" alt="android_dev_patterns_notification_base" /></p>

<p>上面那段代码，运行时候的效果应该如下所示：</p>

<p><img src="/images/android_dev_patterns_notification_base_show.png" alt="android_dev_patterns_notification_base_show" /></p>

<p>为了给上面的Notification添加点击之后的响应效果，我们还需要构造一个<code>PendingIntent</code>作为contentIntent，例如：</p>

<p><code>java
PendingIntent intent = xxx;
builder.setContentIntent(intent);
</code></p>

<p>为了使得Notification更加的具有辨识度，我们还有可能做如下的设置：</p>

<p><img src="/images/android_dev_patterns_notification_set_large.png" alt="android_dev_patterns_notification_set_large" /></p>

<p>从Android 4.1开始，Notification可以支持展开显示的模式，这样一来，Notification就演变出了下面4种不同的风格样式：</p>

<p><img src="/images/android_dev_patterns_notification_4_styles.png" alt="android_dev_patterns_notification_4_styles" /></p>

<p>Notification还提供了快捷操作的功能，如下图所示：</p>

<p><img src="/images/android_dev_patterns_notification_set_action_show.png" alt="android_dev_patterns_notification_set_action_show" />
<img src="/images/android_dev_patterns_notification_set_action.png" alt="android_dev_patterns_notification_set_action" /></p>

<p>除了显示在手机上的Notification，我们还可以给Notification分别设置在Wearable，Auto上的不同表现行为，例如针对可穿戴设备上显示Notification，我们可以如下的设置：</p>

<p><img src="/images/android_dev_patterns_notification_wearable.png" alt="android_dev_patterns_notification_wearable" /></p>

<p>关于更多的Wearable上的Notification相关的知识，还可以参考<a href="https://www.youtube.com/watch?v=N7aJPyvHPgs&amp;feature=iv&amp;src_vid=-iog_fmm6mE&amp;annotation_id=annotation_347477041">Pages of Content</a>与<a href="https://www.youtube.com/watch?v=L4LvKOTkZ7Q&amp;feature=iv&amp;src_vid=-iog_fmm6mE&amp;annotation_id=annotation_2485794965">Stackable Notifications</a></p>

<h2>3）Android 6.0 Marshmallow的运行时权限</h2>

<p>Android 6.0开始引入了新的运行时权限检查授权机制，替代了之前安装应用的时候对权限进行授权的方案。为了避免6.0及以上的机器运行发生运行时异常，我们需要做到至少以下5个步骤：</p>

<ul>
<li><strong>检查系统版本号</strong>：针对6.0以下的系统版本，默认权限在安装的时候已经获取到了，对于6.0开始的版本，才需要做运行时的权限检查。</li>
<li><strong>检查申请的权限</strong>：在使用某个权限之前，需要检查权限是否已经获取到了。</li>
<li><strong>解释申请的权限</strong>：在权限没有获取到的情况下，需要通过<code>shouldShowRequestPermissionRationable()</code>的判断来决定如何给用户进行提示。</li>
<li><strong>执行申请权限操作</strong>：前面判断没有获取到权限，为了能够让功能顺利执行，我们会需要在代码里面再次执行申请此权限的操作。</li>
</ul>


<p><img src="/images/android_dev_patterns_permission_check.png" alt="android_dev_patterns_permission_check" /></p>

<ul>
<li><strong>处理权限申请的结果</strong>：申请权限之后，我们需要处理申请的响应结果，分别处理权限申请成功与失败的情况</li>
</ul>


<p><img src="/images/android_dev_patterns_permission_response.png" alt="android_dev_patterns_permission_response" /></p>

<h2>4）使用MediaSessionCompat操作音乐的播放</h2>

<p>MediaSessionCompat来自Android官方的兼容包，通过它可以告诉Android系统与其他的应用，自己正在播放的内容是什么以及自己支持哪些类型的播放控制：</p>

<p><img src="/images/android_dev_patterns_media_session.png" alt="android_dev_patterns_media_session" /></p>

<p>在Android的官方培训课程中有介绍过关于<a href="http://developer.android.com/training/managing-audio/volume-playback.html">Media Button Receiver</a>的概念，Android系统会把来自蓝牙控制器或者是耳机等其他设备的操作事件转换成Media Button事件传递出来，如果我们的应用程序需要监听这些事件并做出相应的响应，就需要注册MEDIA_BUTTON的action，接收到这些事件之后，再传递给音乐播放模块进行控制处理。</p>

<p><img src="/images/android_dev_patterns_media_receiver.png" alt="android_dev_patterns_media_receiver" /></p>

<p>基于上面的认知，我们现在演示如何使用MediaSessionCompat，下面演示了如何构造一个MediaSessionCompat以及构造完之后通常需要做的三件事情：设置合理的flag，设置回调（在5.0开始会响应onPlay，onPause等等回调），设置激活。</p>

<p><img src="/images/android_dev_patterns_media_usage.png" alt="android_dev_patterns_media_usage" /></p>

<p>搭建好了MediaSessionCompat之后，还需要通过<code>MediaMetadataCompat</code>来传递播放的资料信息，通过<code>PlaybackStateCompat</code>来传递播放的状态信息。</p>

<p><img src="/images/android_dev_patterns_media_set.png" alt="android_dev_patterns_media_set" /></p>

<p>做了上面那些操作之后，MediaSessionCompat的任务就算是完成了。</p>

<p><img src="/images/android_dev_patterns_media_done.png" alt="android_dev_patterns_media_done" /></p>

<h2>5）使用Toolbar替代ActionBar</h2>

<p>自从MaterialDesign开始，Android官方就开始使用Toolbar替代了原来的ActionBar，现在Toolbar已经加入Support兼容包。Toolbar是一个相比起ActionBar更加丰富，更加灵活的组件，另外它的布局本身还是View Hierarchy的一部分，这就意味着可以对Toolbar执行动画操作，增加点击滑动事件等等，甚至我们还可以在一个页面里面加入两个Toolbar。</p>

<p>为了启用Toolbar，首先要做的事情就是关闭当前Activity的ActionBar。我们可以通过使得Activity的主题继承<code>Theme.AppCompat.NoActionBar</code>，然后在对应的XML布局文件中，添加类似下面的toolbar布局信息：</p>

<p>```xml</p>

<!--Toolbar-->


<p>&lt;android.support.v7.widget.Toolbar</p>

<pre><code>android:id="@+id/toolbar_layout"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:layout_alignParentTop="true"
android:minHeight="?attr/actionBarSize"&gt;
</code></pre>

<p>&lt;/android.support.v7.widget.Toolbar>
```</p>

<p>在布局文件中添加Toolbar的信息之后，需要启动Toolbar替代ActionBar，需要像下面一样做设置：</p>

<p>```java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar_layout);
setSupportActionBar(toolbar);
</code></pre>

<p>}
```</p>

<p>关于更多Toolbar的细节，请参考官方文档<a href="https://developer.android.com/reference/android/support/v7/widget/Toolbar.html">https://developer.android.com/reference/android/support/v7/widget/Toolbar.html</a></p>

<h2>6）使用AppBarLayout并处理滑动手势</h2>

<p>AppBarLayout是一个在android.support.design兼容包（这里有关于该兼容包的官方博客介绍<a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">http://android-developers.blogspot.com/2015/05/android-design-support-library.html</a>）里面的新推出的组件，它是一个垂直方向的LinearLayout，包装了很多Material Design的设计元素，例如滑动手势的处理。我们可以使用<code>app:layout_scrollFlags</code>这样的标签来设置滑动的行为表现。关于App Bar，官方还有这样一段描述：</p>

<p><img src="/images/android_dev_patterns_appbar_des.png" alt="android_dev_patterns_appbar_des" /></p>

<p>使用AppBarLayout需要注意下面几个要点：</p>

<ul>
<li>首先，AppBarLayout必须作为<code>CoordinatorLayout</code>的直接子View</li>
<li>其次，在AppBarLayout里面必须包含一个ToolBar</li>
<li>最后，在CoordinatorLayout里面可以添加那些可以滑动的组件，例如RecyclerView</li>
</ul>


<p>一个标准的布局文件应该是类似下面结构的：</p>

<p><img src="/images/android_dev_patterns_appbar_scroll_xml.png" alt="android_dev_patterns_appbar_scroll_xml" /></p>

<p>我们需要注意，在Toolbar里面设置的layout_scrollFlags会影响到滑动之后的显示效果，请看下面的具体解释：</p>

<p><img src="/images/android_dev_patterns_appbar_scroll_flag.png" alt="android_dev_patterns_appbar_scroll_flag" /></p>

<h2>7）使用SearchView来实现搜索功能</h2>

<p>关于在使用搜索的时候及时显示给用户的候选词，会需要根据数据的类型以及具体的情况做不同的处理，这里先暂时不讨论那一块的内容。</p>

<p><img src="/images/android_dev_patterns_searchview_show.png" alt="android_dev_patterns_searchview_show" />
<img src="/images/android_dev_patterns_searchview_tips.png" alt="android_dev_patterns_searchview_tips" /></p>

<p>上面的图示已经清楚的演示了使用SearchView处理搜索的通常情况，关于如何实现这个功能，需要做到以下几个步骤：</p>

<ul>
<li>在Menu的XML文件中，声明使用SearchView</li>
</ul>


<p><img src="/images/android_dev_patterns_searchview_xml.png" alt="android_dev_patterns_searchview_xml" /></p>

<ul>
<li>在onCreateOptionsMenu的回调函数里面获取到SearchView，并设置监听（请注意使用MenuItemCompat的那行代码，否则会出现很多兼容性问题，获取不到这个View等等奇怪的BUG），在监听回调里面处理业务逻辑</li>
</ul>


<p><img src="/images/android_dev_patterns_searchview_code.png" alt="android_dev_patterns_searchview_code" /></p>

<p>至此，其实就已经实现了一个基础的搜索功能。但是，如果为了能够让自己的应用的某些功能被Android系统的Search功能检索到，我们就需要做更进一步的操作，例如定义Searchable，实现一个SearchableActivity，响应系统的Search行为等等。国内的应用很少会去关注这个功能，这里就不展开了，感兴趣点击下面的链接进一步学习：<a href="https://developer.android.com/guide/topics/search/index.html">https://developer.android.com/guide/topics/search/index.html</a></p>

<h2>8）Navigation Drawer, DrawerLayout, NavigationView</h2>

<p>Navigation Drawer是Material Design当中很重要的一种设计元素，为了能够快速的实现这种设计，Android在新的design support包里面为我们提供了DrawerLayout与NavigationView。</p>

<p><img src="/images/android_dev_patterns_navigation_show.png" alt="android_dev_patterns_navigation_show" /></p>

<p>实现这样的一个功能，我们需要在XML中写下类似下面的布局文件</p>

<p><img src="/images/android_dev_patterns_navigation_xml.png" alt="android_dev_patterns_navigation_xml" /></p>

<p>在NavigationView中有两个重要的标签，app:headerLayout与app:menu，分别代表了拉出菜单的顶部布局与下面的菜单项列表。创建菜单项列表，可以使用类似下面的MenuItem文件：</p>

<p><img src="/images/android_dev_patterns_navigation_menu.png" alt="android_dev_patterns_navigation_menu" /></p>

<p><code>android:checked</code>表示当前选中的Item，会被系统Highlight出来。除了上面简单的平铺的菜单，还可以使用菜单嵌套的方式实现多级的菜单。关于点击具体某个菜单的时候的监听与响应，需要做如下的设置：</p>

<p><img src="/images/android_dev_patterns_navigation_click.png" alt="android_dev_patterns_navigation_click" /></p>

<p>除了点击菜单事件，我们还需要处理整个侧滑菜单的打开与关闭事件，当我们给DrawerLayout设置了setDrawerListener之后，可以得到下面两个回调：</p>

<p><img src="/images/android_dev_patterns_navigation_drawer_event.png" alt="android_dev_patterns_navigation_drawer_event" /></p>

<p>大多数时候，侧滑菜单都是从左到右滑出的，但是我们也可以做到从右往左滑出，只需要在DrawerLayout的菜单布局LinearLayout里面修改一下margin的相关属性即可：</p>

<p><img src="/images/android_dev_patterns_navigation_right.png" alt="android_dev_patterns_navigation_right" /></p>

<h2>9）Tabs and ViewPager</h2>

<p><img src="/images/android_dev_patterns_viewpager_show.png" alt="android_dev_patterns_viewpager_show" /></p>

<p>ViewPager是Android上面实现横向滑动的基础组件，能够帮助大家迅速搭建类似上面图示一样的左右滑动交互设计。ViewPager需要使用PagerAdapter来提供内容，除了PagerAdpater，Android还提供了FragmentPagerAdpater与FragmentStatePagerAdapter，前者会把所有的fragment都保存在内存中，以便提高切换速度，后者仅仅保留了fragment状态信息，fragment还是会进行正常的重建与销毁。一个典型的使用demo代码如下：</p>

<p><img src="/images/android_dev_patterns_viewpager_code.png" alt="android_dev_patterns_viewpager_code" /></p>

<p>为了实现前面图示的Tab与ViewPager的绑定，我们可以使用<a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">Android Design Support Library</a>提供的<code>TabLayout</code>，仅仅需要按照下面的代码示例一样把TabLayout与ViewPager做一个绑定，就能够实现左右滑动与点击Tab快速切换的功能：</p>

<p><img src="/images/android_dev_patterns_viewpager_tablayout.png" alt="android_dev_patterns_viewpager_tablayout" /></p>

<p>关于Material Design里面的Tabs设计，请再参考<a href="http://www.google.com/design/spec/components/tabs.html">http://www.google.com/design/spec/components/tabs.html</a>以及官方Training课程里面的<a href="http://developer.android.com/training/implementing-navigation/lateral.html">http://developer.android.com/training/implementing-navigation/lateral.html</a></p>

<h2>10）Making Apps Accessible</h2>

<p>为了照顾部分视力或者听觉不好的用户，我们需要做一定的处理使得自己的应用能够被每一个可用。Android系统为了帮助应用实现辅助功能，提供了诸如文本朗读，触感反馈，指向炳导航，手势导航等等功能来更好的帮助用户使用这些应用。</p>

<p><img src="/images/android_dev_patterns_accessible_feature.png" alt="android_dev_patterns_accessible_feature" /></p>

<p>为了确保你的应用能够被Android系统提供的辅助功能正常使用，需要做以下三个步骤的检查：</p>

<ul>
<li><strong>Content Description</strong>：确保类似ImageView，ImageButton，CheckBox等组件都包含了content descrption。</li>
</ul>


<p><img src="/images/android_dev_patterns_accessible_content.png" alt="android_dev_patterns_accessible_content" /></p>

<ul>
<li><strong>Focus Order</strong>：确保给布局里面的关键元素增加了Focus的指示顺序，只有这样，辅助功能才能够在指向导航的时候帮助用户按照指定的顺序来聚焦界面元素。</li>
</ul>


<p><img src="/images/android_dev_patterns_accessible_focus_order.png" alt="android_dev_patterns_accessible_focus_order" />
<img src="/images/android_dev_patterns_accessible_focus_code.png" alt="android_dev_patterns_accessible_focus_code" /></p>

<ul>
<li><strong>Feedback Mechanisms</strong>：确保部分关键的操作有多个反馈，例如当短信来的时候，既有声音也有震动，这样才能够确保听力不好的用户可以通过震动的反馈来感知到响应。</li>
</ul>


<p>更多关于辅助功能的知识，请参考<a href="http://developer.android.com/guide/topics/ui/accessibility/checklist.html">http://developer.android.com/guide/topics/ui/accessibility/checklist.html</a></p>
]]></content>
  </entry>
  
</feed>
