<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 胡凯]]></title>
  <link href="http://hukai.me/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2015-10-18T16:32:57+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[HuKai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android开发最佳实践]]></title>
    <link href="http://hukai.me/android-dev-patterns/"/>
    <updated>2015-10-02T15:38:00+08:00</updated>
    <id>http://hukai.me/android-dev-patterns</id>
    <content type="html"><![CDATA[<p><img src="/images/android_dev_patterns_logo.png" alt="android_dev_patterns_logo" /></p>

<p>前段时间，Google公布了<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc-lJo_RGGXL2Psr8vVCTWjM">Android开发最佳实践</a>的一系列课程，涉及到一些平时开发过程中应该保持的良好习惯以及如何使用最新的<a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">Android Design Support Library</a>来快速实现官方推荐的Material Design样式的应用。下面是个人的学习摘要总结，不对的地方请多多交流指点，谢谢！</p>

<h2>1）注意对隐式Intent的运行时检查保护</h2>

<p>类似打开相机，发送图片等隐式Intent，是并不一定能够在所有的Android设备上都正常运行。例如打开相机的隐式Intent，如果系统相机应用被关闭或者不存在相机应用，又或者是相机应用的某些权限被关闭等等情况都可能导致这个隐式的Intent无法正常工作。一旦发生隐式Intent找不到合适的调用组件的情况，系统就会抛出<code>ActivityNotFoundException</code>的异常，如果我们的应用没有对这个异常做任何处理，那应用就会发生Crash。</p>

<p>预防这个问题的最佳解决方案是在发出这个隐式Intent之前调用<code>resolveActivity</code>做检查，关于这个API的解释以及用法如下：</p>

<!-- More -->


<p><img src="/images/android_dev_patterns_implicit_intent.png" alt="android_dev_patterns_implicit_intent" /></p>

<p>然后这个API的使用范例如下：</p>

<p>```java
Intent intent = new Intent(Intent.ACTION_XXX);
ComponentName componentName = intent.resolveActivity(getPackageManager());
if(componentName != null) {</p>

<pre><code>String className = componentName.getClassName();
</code></pre>

<p>}
```</p>

<h2>2）使用NotificationCompat兼容包来处理消息通知</h2>

<p>为了解决Android系统版本差异导致的Notification兼容性问题，Android官方提供了<code>NotificationCompat</code>兼容类来帮助开发实现体验统一的Notification。通常来说，建立一个Notification至少会有三种元素：图标，标题，文本。我们通常会使用如下的代码来实现一个基础的Notification功能：</p>

<p><img src="/images/android_dev_patterns_notification_base.png" alt="android_dev_patterns_notification_base" /></p>

<p>上面那段代码，运行时候的效果应该如下所示：</p>

<p><img src="/images/android_dev_patterns_notification_base_show.png" alt="android_dev_patterns_notification_base_show" /></p>

<p>为了给上面的Notification添加点击之后的响应效果，我们还需要构造一个<code>PendingIntent</code>作为contentIntent，例如：</p>

<p><code>java
PendingIntent intent = xxx;
builder.setContentIntent(intent);
</code></p>

<p>为了使得Notification更加的具有辨识度，我们还有可能做如下的设置：</p>

<p><img src="/images/android_dev_patterns_notification_set_large.png" alt="android_dev_patterns_notification_set_large" /></p>

<p>从Android 4.1开始，Notification可以支持展开显示的模式，这样一来，Notification就演变出了下面4种不同的风格样式：</p>

<p><img src="/images/android_dev_patterns_notification_4_styles.png" alt="android_dev_patterns_notification_4_styles" /></p>

<p>Notification还提供了快捷操作的功能，如下图所示：</p>

<p><img src="/images/android_dev_patterns_notification_set_action_show.png" alt="android_dev_patterns_notification_set_action_show" />
<img src="/images/android_dev_patterns_notification_set_action.png" alt="android_dev_patterns_notification_set_action" /></p>

<p>除了显示在手机上的Notification，我们还可以给Notification分别设置在Wearable，Auto上的不同表现行为，例如针对可穿戴设备上显示Notification，我们可以如下的设置：</p>

<p><img src="/images/android_dev_patterns_notification_wearable.png" alt="android_dev_patterns_notification_wearable" /></p>

<p>关于更多的Wearable上的Notification相关的知识，还可以参考<a href="https://www.youtube.com/watch?v=N7aJPyvHPgs&amp;feature=iv&amp;src_vid=-iog_fmm6mE&amp;annotation_id=annotation_347477041">Pages of Content</a>与<a href="https://www.youtube.com/watch?v=L4LvKOTkZ7Q&amp;feature=iv&amp;src_vid=-iog_fmm6mE&amp;annotation_id=annotation_2485794965">Stackable Notifications</a></p>

<h2>3）Android 6.0 Marshmallow的运行时权限</h2>

<p>Android 6.0开始引入了新的运行时权限检查授权机制，替代了之前安装应用的时候对权限进行授权的方案。为了避免6.0及以上的机器运行发生运行时异常，我们需要做到至少以下5个步骤：</p>

<ul>
<li><strong>检查系统版本号</strong>：针对6.0以下的系统版本，默认权限在安装的时候已经获取到了，对于6.0开始的版本，才需要做运行时的权限检查。</li>
<li><strong>检查申请的权限</strong>：在使用某个权限之前，需要检查权限是否已经获取到了。</li>
<li><strong>解释申请的权限</strong>：在权限没有获取到的情况下，需要通过<code>shouldShowRequestPermissionRationable()</code>的判断来决定如何给用户进行提示。</li>
<li><strong>执行申请权限操作</strong>：前面判断没有获取到权限，为了能够让功能顺利执行，我们会需要在代码里面再次执行申请此权限的操作。</li>
</ul>


<p><img src="/images/android_dev_patterns_permission_check.png" alt="android_dev_patterns_permission_check" /></p>

<ul>
<li><strong>处理权限申请的结果</strong>：申请权限之后，我们需要处理申请的响应结果，分别处理权限申请成功与失败的情况</li>
</ul>


<p><img src="/images/android_dev_patterns_permission_response.png" alt="android_dev_patterns_permission_response" /></p>

<h2>4）使用MediaSessionCompat操作音乐的播放</h2>

<p>MediaSessionCompat来自Android官方的兼容包，通过它可以告诉Android系统与其他的应用，自己正在播放的内容是什么以及自己支持哪些类型的播放控制：</p>

<p><img src="/images/android_dev_patterns_media_session.png" alt="android_dev_patterns_media_session" /></p>

<p>在Android的官方培训课程中有介绍过关于<a href="http://developer.android.com/training/managing-audio/volume-playback.html">Media Button Receiver</a>的概念，Android系统会把来自蓝牙控制器或者是耳机等其他设备的操作事件转换成Media Button事件传递出来，如果我们的应用程序需要监听这些事件并做出相应的响应，就需要注册MEDIA_BUTTON的action，接收到这些事件之后，再传递给音乐播放模块进行控制处理。</p>

<p><img src="/images/android_dev_patterns_media_receiver.png" alt="android_dev_patterns_media_receiver" /></p>

<p>基于上面的认知，我们现在演示如何使用MediaSessionCompat，下面演示了如何构造一个MediaSessionCompat以及构造完之后通常需要做的三件事情：设置合理的flag，设置回调（在5.0开始会响应onPlay，onPause等等回调），设置激活。</p>

<p><img src="/images/android_dev_patterns_media_usage.png" alt="android_dev_patterns_media_usage" /></p>

<p>搭建好了MediaSessionCompat之后，还需要通过<code>MediaMetadataCompat</code>来传递播放的资料信息，通过<code>PlaybackStateCompat</code>来传递播放的状态信息。</p>

<p><img src="/images/android_dev_patterns_media_set.png" alt="android_dev_patterns_media_set" /></p>

<p>做了上面那些操作之后，MediaSessionCompat的任务就算是完成了。</p>

<p><img src="/images/android_dev_patterns_media_done.png" alt="android_dev_patterns_media_done" /></p>

<h2>5）使用Toolbar替代ActionBar</h2>

<p>自从MaterialDesign开始，Android官方就开始使用Toolbar替代了原来的ActionBar，现在Toolbar已经加入Support兼容包。Toolbar是一个相比起ActionBar更加丰富，更加灵活的组件，另外它的布局本身还是View Hierarchy的一部分，这就意味着可以对Toolbar执行动画操作，增加点击滑动事件等等，甚至我们还可以在一个页面里面加入两个Toolbar。</p>

<p>为了启用Toolbar，首先要做的事情就是关闭当前Activity的ActionBar。我们可以通过使得Activity的主题继承<code>Theme.AppCompat.NoActionBar</code>，然后在对应的XML布局文件中，添加类似下面的toolbar布局信息：</p>

<p>```xml</p>

<!--Toolbar-->


<p>&lt;android.support.v7.widget.Toolbar</p>

<pre><code>android:id="@+id/toolbar_layout"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:layout_alignParentTop="true"
android:minHeight="?attr/actionBarSize"&gt;
</code></pre>

<p>&lt;/android.support.v7.widget.Toolbar>
```</p>

<p>在布局文件中添加Toolbar的信息之后，需要启动Toolbar替代ActionBar，需要像下面一样做设置：</p>

<p>```java
@Override
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar_layout);
setSupportActionBar(toolbar);
</code></pre>

<p>}
```</p>

<p>关于更多Toolbar的细节，请参考官方文档<a href="https://developer.android.com/reference/android/support/v7/widget/Toolbar.html">https://developer.android.com/reference/android/support/v7/widget/Toolbar.html</a></p>

<h2>6）使用AppBarLayout并处理滑动手势</h2>

<p>AppBarLayout是一个在android.support.design兼容包（这里有关于该兼容包的官方博客介绍<a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">http://android-developers.blogspot.com/2015/05/android-design-support-library.html</a>）里面的新推出的组件，它是一个垂直方向的LinearLayout，包装了很多Material Design的设计元素，例如滑动手势的处理。我们可以使用<code>app:layout_scrollFlags</code>这样的标签来设置滑动的行为表现。关于App Bar，官方还有这样一段描述：</p>

<p><img src="/images/android_dev_patterns_appbar_des.png" alt="android_dev_patterns_appbar_des" /></p>

<p>使用AppBarLayout需要注意下面几个要点：</p>

<ul>
<li>首先，AppBarLayout必须作为<code>CoordinatorLayout</code>的直接子View</li>
<li>其次，在AppBarLayout里面必须包含一个ToolBar</li>
<li>最后，在CoordinatorLayout里面可以添加那些可以滑动的组件，例如RecyclerView</li>
</ul>


<p>一个标准的布局文件应该是类似下面结构的：</p>

<p><img src="/images/android_dev_patterns_appbar_scroll_xml.png" alt="android_dev_patterns_appbar_scroll_xml" /></p>

<p>我们需要注意，在Toolbar里面设置的layout_scrollFlags会影响到滑动之后的显示效果，请看下面的具体解释：</p>

<p><img src="/images/android_dev_patterns_appbar_scroll_flag.png" alt="android_dev_patterns_appbar_scroll_flag" /></p>

<h2>7）使用SearchView来实现搜索功能</h2>

<p>关于在使用搜索的时候及时显示给用户的候选词，会需要根据数据的类型以及具体的情况做不同的处理，这里先暂时不讨论那一块的内容。</p>

<p><img src="/images/android_dev_patterns_searchview_show.png" alt="android_dev_patterns_searchview_show" />
<img src="/images/android_dev_patterns_searchview_tips.png" alt="android_dev_patterns_searchview_tips" /></p>

<p>上面的图示已经清楚的演示了使用SearchView处理搜索的通常情况，关于如何实现这个功能，需要做到以下几个步骤：</p>

<ul>
<li>在Menu的XML文件中，声明使用SearchView</li>
</ul>


<p><img src="/images/android_dev_patterns_searchview_xml.png" alt="android_dev_patterns_searchview_xml" /></p>

<ul>
<li>在onCreateOptionsMenu的回调函数里面获取到SearchView，并设置监听（请注意使用MenuItemCompat的那行代码，否则会出现很多兼容性问题，获取不到这个View等等奇怪的BUG），在监听回调里面处理业务逻辑</li>
</ul>


<p><img src="/images/android_dev_patterns_searchview_code.png" alt="android_dev_patterns_searchview_code" /></p>

<p>至此，其实就已经实现了一个基础的搜索功能。但是，如果为了能够让自己的应用的某些功能被Android系统的Search功能检索到，我们就需要做更进一步的操作，例如定义Searchable，实现一个SearchableActivity，响应系统的Search行为等等。国内的应用很少会去关注这个功能，这里就不展开了，感兴趣点击下面的链接进一步学习：<a href="https://developer.android.com/guide/topics/search/index.html">https://developer.android.com/guide/topics/search/index.html</a></p>

<h2>8）Navigation Drawer, DrawerLayout, NavigationView</h2>

<p>Navigation Drawer是Material Design当中很重要的一种设计元素，为了能够快速的实现这种设计，Android在新的design support包里面为我们提供了DrawerLayout与NavigationView。</p>

<p><img src="/images/android_dev_patterns_navigation_show.png" alt="android_dev_patterns_navigation_show" /></p>

<p>实现这样的一个功能，我们需要在XML中写下类似下面的布局文件</p>

<p><img src="/images/android_dev_patterns_navigation_xml.png" alt="android_dev_patterns_navigation_xml" /></p>

<p>在NavigationView中有两个重要的标签，app:headerLayout与app:menu，分别代表了拉出菜单的顶部布局与下面的菜单项列表。创建菜单项列表，可以使用类似下面的MenuItem文件：</p>

<p><img src="/images/android_dev_patterns_navigation_menu.png" alt="android_dev_patterns_navigation_menu" /></p>

<p><code>android:checked</code>表示当前选中的Item，会被系统Highlight出来。除了上面简单的平铺的菜单，还可以使用菜单嵌套的方式实现多级的菜单。关于点击具体某个菜单的时候的监听与响应，需要做如下的设置：</p>

<p><img src="/images/android_dev_patterns_navigation_click.png" alt="android_dev_patterns_navigation_click" /></p>

<p>除了点击菜单事件，我们还需要处理整个侧滑菜单的打开与关闭事件，当我们给DrawerLayout设置了setDrawerListener之后，可以得到下面两个回调：</p>

<p><img src="/images/android_dev_patterns_navigation_drawer_event.png" alt="android_dev_patterns_navigation_drawer_event" /></p>

<p>大多数时候，侧滑菜单都是从左到右滑出的，但是我们也可以做到从右往左滑出，只需要在DrawerLayout的菜单布局LinearLayout里面修改一下margin的相关属性即可：</p>

<p><img src="/images/android_dev_patterns_navigation_right.png" alt="android_dev_patterns_navigation_right" /></p>

<h2>9）Tabs and ViewPager</h2>

<p><img src="/images/android_dev_patterns_viewpager_show.png" alt="android_dev_patterns_viewpager_show" /></p>

<p>ViewPager是Android上面实现横向滑动的基础组件，能够帮助大家迅速搭建类似上面图示一样的左右滑动交互设计。ViewPager需要使用PagerAdapter来提供内容，除了PagerAdpater，Android还提供了FragmentPagerAdpater与FragmentStatePagerAdapter，前者会把所有的fragment都保存在内存中，以便提高切换速度，后者仅仅保留了fragment状态信息，fragment还是会进行正常的重建与销毁。一个典型的使用demo代码如下：</p>

<p><img src="/images/android_dev_patterns_viewpager_code.png" alt="android_dev_patterns_viewpager_code" /></p>

<p>为了实现前面图示的Tab与ViewPager的绑定，我们可以使用<a href="http://android-developers.blogspot.com/2015/05/android-design-support-library.html">Android Design Support Library</a>提供的<code>TabLayout</code>，仅仅需要按照下面的代码示例一样把TabLayout与ViewPager做一个绑定，就能够实现左右滑动与点击Tab快速切换的功能：</p>

<p><img src="/images/android_dev_patterns_viewpager_tablayout.png" alt="android_dev_patterns_viewpager_tablayout" /></p>

<p>关于Material Design里面的Tabs设计，请再参考<a href="http://www.google.com/design/spec/components/tabs.html">http://www.google.com/design/spec/components/tabs.html</a>以及官方Training课程里面的<a href="http://developer.android.com/training/implementing-navigation/lateral.html">http://developer.android.com/training/implementing-navigation/lateral.html</a></p>

<h2>10）Making Apps Accessible</h2>

<p>为了照顾部分视力或者听觉不好的用户，我们需要做一定的处理使得自己的应用能够被每一个可用。Android系统为了帮助应用实现辅助功能，提供了诸如文本朗读，触感反馈，指向炳导航，手势导航等等功能来更好的帮助用户使用这些应用。</p>

<p><img src="/images/android_dev_patterns_accessible_feature.png" alt="android_dev_patterns_accessible_feature" /></p>

<p>为了确保你的应用能够被Android系统提供的辅助功能正常使用，需要做以下三个步骤的检查：</p>

<ul>
<li><strong>Content Description</strong>：确保类似ImageView，ImageButton，CheckBox等组件都包含了content descrption。</li>
</ul>


<p><img src="/images/android_dev_patterns_accessible_content.png" alt="android_dev_patterns_accessible_content" /></p>

<ul>
<li><strong>Focus Order</strong>：确保给布局里面的关键元素增加了Focus的指示顺序，只有这样，辅助功能才能够在指向导航的时候帮助用户按照指定的顺序来聚焦界面元素。</li>
</ul>


<p><img src="/images/android_dev_patterns_accessible_focus_order.png" alt="android_dev_patterns_accessible_focus_order" />
<img src="/images/android_dev_patterns_accessible_focus_code.png" alt="android_dev_patterns_accessible_focus_code" /></p>

<ul>
<li><strong>Feedback Mechanisms</strong>：确保部分关键的操作有多个反馈，例如当短信来的时候，既有声音也有震动，这样才能够确保听力不好的用户可以通过震动的反馈来感知到响应。</li>
</ul>


<p>更多关于辅助功能的知识，请参考<a href="http://developer.android.com/guide/topics/ui/accessibility/checklist.html">http://developer.android.com/guide/topics/ui/accessibility/checklist.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android内存优化之OOM]]></title>
    <link href="http://hukai.me/android-performance-oom/"/>
    <updated>2015-09-12T14:53:00+08:00</updated>
    <id>http://hukai.me/android-performance-oom</id>
    <content type="html"><![CDATA[<p>Android的内存优化是性能优化中很重要的一部分，而避免OOM又是内存优化中比较核心的一点，这是一篇关于内存优化中如何避免OOM的总结性概要文章，内容大多都是和OOM有关的实践总结概要。理解错误或是偏差的地方，还请多包涵指正，谢谢！</p>

<h2>(一)Android的内存管理机制</h2>

<p>Google在Android的官网上有这样一篇文章，初步介绍了Android是如何管理应用的进程与内存分配：<a href="http://developer.android.com/training/articles/memory.html">http://developer.android.com/training/articles/memory.html</a>。
Android系统的Dalvik虚拟机扮演了常规的内存垃圾自动回收的角色，Android系统没有为内存提供交换区，它使用<a href="http://en.wikipedia.org/wiki/Paging">paging</a>与<a href="http://en.wikipedia.org/wiki/Memory-mapped_files">memory-mapping(mmapping)</a>的机制来管理内存，下面简要概述一些Android系统中重要的内存管理基础概念。</p>

<h3>1）共享内存</h3>

<p>Android系统通过下面几种方式来实现共享内存：</p>

<ul>
<li>Android应用的进程都是从一个叫做Zygote的进程fork出来的。Zygote进程在系统启动并且载入通用的framework的代码与资源之后开始启动。为了启动一个新的程序进程，系统会fork Zygote进程生成一个新的进程，然后在新的进程中加载并运行应用程序的代码。这使得大多数的RAM pages被用来分配给framework的代码，同时使得RAM资源能够在应用的所有进程之间进行共享。</li>
<li>大多数static的数据被mmapped到一个进程中。这不仅仅使得同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被paged out。常见的static数据包括Dalvik Code，app resources，so文件等。</li>
<li>大多数情况下，Android通过显式的分配共享内存区域(例如ashmem或者gralloc)来实现动态RAM区域能够在不同进程之间进行共享的机制。例如，Window Surface在App与Screen Compositor之间使用共享的内存，Cursor Buffers在Content Provider与Clients之间共享内存。</li>
</ul>


<!-- More -->


<h3>2）分配与回收内存</h3>

<ul>
<li>每一个进程的Dalvik heap都反映了使用内存的占用范围。这就是通常逻辑意义上提到的Dalvik Heap Size，它可以随着需要进行增长，但是增长行为会有一个系统为它设定的上限。</li>
<li>逻辑上讲的Heap Size和实际物理意义上使用的内存大小是不对等的，Proportional Set Size(PSS)记录了应用程序自身占用以及和其他进程进行共享的内存。</li>
<li>Android系统并不会对Heap中空闲内存区域做碎片整理。系统仅仅会在新的内存分配之前判断Heap的尾端剩余空间是否足够，如果空间不够会触发gc操作，从而腾出更多空闲的内存空间。在Android的高级系统版本里面针对Heap空间有一个Generational Heap Memory的模型，最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。系统会根据内存中不同的内存数据类型分别执行不同的gc操作。例如，刚分配到Young Generation区域的对象通常更容易被销毁回收，同时在Young Generation区域的gc操作速度会比Old Generation区域的gc操作速度更快。如下图所示：</li>
</ul>


<p><img src="/images/memory_mode_generation.png" alt="memory_mode_generation" />
<img src="/images/android_memory_gc_mode.png" alt="android_memory_gc_mode" /></p>

<p>每一个Generation的内存区域都有固定的大小，随着新的对象陆续被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阀值时，会触发GC的操作，以便腾出空间来存放其他新的对象。如下图所示：</p>

<p><img src="/images/gc_threshold.png" alt="gc_threshold" /></p>

<p>通常情况下，GC发生的时候，所有的线程都是会被暂停的。执行GC所占用的时间和它发生在哪一个Generation也有关系，Young Generation中的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。执行时间的长短也和当前Generation中的对象数量有关，遍历树结构查找20000个对象比起遍历50个对象自然是要慢很多的。</p>

<h3>3）限制应用的内存</h3>

<ul>
<li>为了整个Android系统的内存控制需要，Android系统为每一个应用程序都设置了一个硬性的Dalvik Heap Size最大限制阈值，这个阈值在不同的设备上会因为RAM大小不同而各有差异。如果你的应用占用内存空间已经接近这个阈值，此时再尝试分配内存的话，很容易引起<code>OutOfMemoryError</code>的错误。</li>
<li><code>ActivityManager.getMemoryClass()</code>可以用来查询当前应用的Heap Size阈值，这个方法会返回一个整数，表明你的应用的Heap Size阈值是多少Mb(megabates)。</li>
</ul>


<h3>4）应用切换操作</h3>

<ul>
<li>Android系统并不会在用户切换应用的时候做交换内存的操作。Android会把那些不包含Foreground组件的应用进程放到LRU Cache中。例如，当用户开始启动了一个应用，系统会为它创建了一个进程，但是当用户离开这个应用，此进程并不会立即被销毁，而是会被放到系统的Cache当中，如果用户后来再切换回到这个应用，此进程就能够被马上完整的恢复，从而实现应用的快速切换。</li>
<li>如果你的应用中有一个被缓存的进程，这个进程会占用一定的内存空间，它会对系统的整体性能有影响。因此当系统开始进入Low Memory的状态时，它会由系统根据LRU的规则与应用的优先级，内存占用情况以及其他因素的影响综合评估之后决定是否被杀掉。</li>
<li>对于那些非foreground的进程，Android系统是如何判断Kill掉哪些进程的问题，请参考<a href="http://developer.android.com/guide/components/processes-and-threads.html">Processes and Threads</a>。</li>
</ul>


<h2>(二)OOM（OutOfMemory）</h2>

<p>前面我们提到过使用getMemoryClass()的方法可以得到Dalvik Heap的阈值。简要的获取某个应用的内存占用情况可以参考下面的示例（
关于更多内存查看的知识，可以参考这篇官方教程：<a href="http://developer.android.com/tools/debugging/debugging-memory.html">Investigating Your RAM Usage</a>
）</p>

<h3>1）查看内存使用情况</h3>

<ul>
<li>通过命令行查看内存详细占用情况：</li>
</ul>


<p><img src="/images/android_perf_oom_dumpsys_meminfo.png" alt="android_perf_oom_dumpsys_meminfo.png" /></p>

<ul>
<li>通过Android Studio的Memory Monitor查看内存中Dalvik Heap的实时变化</li>
</ul>


<p><img src="/images/android_perf_oom_studio_mem_monitor.png" alt="android_perf_oom_studio_mem_monitor" />
<img src="/images/memory_monitor_free_allocation.png" alt="memory_monitor_free_allocation" />
<img src="/images/memory_monitor_gc_event.png" alt="memory_monitor_gc_event" /></p>

<h3>2）发生OOM的条件</h3>

<p>关于Native Heap，Dalvik Heap，Pss等内存管理机制比较复杂，这里不展开描述。简单的说，通过不同的内存分配方式（malloc/mmap/JNIEnv/etc）对不同的对象（bitmap，etc）进行操作会因为Android系统版本的差异而产生不同的行为，对Native Heap与Dalvik Heap以及OOM的判断条件都会有所影响。在2.x的系统上，我们常常可以看到Heap Size的total值明显超过了通过getMemoryClass()获取到的阈值而不会发生OOM的情况，那么针对2.x与4.x的Android系统，到底是如何判断会发生OOM呢？</p>

<ul>
<li><p>Android 2.x系统
GC LOG中的dalvik allocated + external allocated + 新分配的大小 >= getMemoryClass()值的时候就会发生OOM。
例如，假设有这么一段Dalvik输出的GC LOG：GC_FOR_MALLOC free 2K, 13% free 32586K/37455K, external 8989K/10356K, paused 20ms，那么32586+8989+(新分配23975)=65550>64M时，就会发生OOM。</p></li>
<li><p>Android 4.x系统
Android 4.x的系统废除了external的计数器，类似bitmap的分配改到dalvik的java heap中申请，只要allocated + 新分配的内存 >= getMemoryClass()的时候就会发生OOM，如下图所示（虽然图示演示的是art运行环境，但是统计规则还是和dalvik保持一致）</p></li>
</ul>


<p><img src="/images/android_perf_oom_gc_log.png" alt="android_perf_oom_gc_log.png" /></p>

<h2>(三)如何避免OOM总结</h2>

<p>前面介绍了一些基础的内存管理机制以及OOM的基础知识，那么在实践操作当中，有哪些指导性的规则可以参考呢？归纳下来，可以从四个方面着手，首先是减小对象的内存占用，其次是内存对象的重复利用，然后是避免对象的内存泄露，最后是内存使用策略优化。</p>

<h3>减小对象的内存占用</h3>

<p>避免OOM的第一步就是要尽量减少新分配出来的对象占用内存的大小，尽量使用更加轻量的对象。</p>

<h4>1）使用更加轻量的数据结构</h4>

<p>例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构，下图演示了HashMap的简要工作原理，相比起Android系统专门为移动操作系统编写的ArrayMap容器，在大多数情况下，都显示效率低下，更占内存。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。</p>

<p><img src="/images/android_perf_3_arraymap_key_value.png" alt="android_perf_3_arraymap_key_value" /></p>

<p>关于更多ArrayMap/SparseArray的讨论，请参考<a href="http://hukai.me/android-performance-patterns-season-3/">http://hukai.me/android-performance-patterns-season-3/</a>的前三个段落</p>

<h4>2）避免在Android里面使用Enum</h4>

<p>Android官方培训课程提到过<strong>"Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android."</strong>，具体原理请参考<a href="http://hukai.me/android-performance-patterns-season-3/">http://hukai.me/android-performance-patterns-season-3/</a>，所以请避免在Android里面使用到枚举。</p>

<h4>3）减小Bitmap对象的内存占用</h4>

<p>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施：</p>

<ul>
<li>inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。</li>
<li>decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。</li>
</ul>


<h4>4）使用更小的图片</h4>

<p>在设计给到资源图片的时候，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</p>

<h3>内存对象的重复利用</h3>

<p>大多数对象的复用，最终实施的方案都是利用对象池技术，要么是在编写代码的时候显式的在程序里面去创建对象池，然后处理好复用的实现逻辑，要么就是利用系统框架既有的某些复用特性达到减少对象的重复创建，从而减少内存的分配与回收。</p>

<p><img src="/images/android_perf_2_object_pool.png" alt="android_perf_2_object_pool" /></p>

<p>在Android上面最常用的一个缓存算法是LRU(Least Recently Use)，简要操作原理如下图所示：</p>

<p><img src="/images/android_perf_2_lru_mode.png" alt="android_perf_2_lru_mode" /></p>

<h4>1）复用系统自带的资源</h4>

<p>Android系统本身内置了很多的资源，例如字符串/颜色/图片/动画/样式以及简单布局等等，这些资源都可以在应用程序中直接引用。这样做不仅仅可以减少应用程序的自身负重，减小APK的大小，另外还可以一定程度上减少内存的开销，复用性更好。但是也有必要留意Android系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。</p>

<h4>2）注意在ListView/GridView等出现大量重复子组件的视图里面对ConvertView的复用</h4>

<p><img src="/images/android_perf_oom_listview_recycle.png" alt="android_perf_oom_listview_recycle" /></p>

<h4>3）Bitmap对象的复用</h4>

<ul>
<li>在ListView与GridView等显示大量图片的控件里面需要使用LRU的机制来缓存处理好的Bitmap。</li>
</ul>


<p><img src="/images/android_perf_2_inbitmap_old.png" alt="android_perf_2_inbitmap_old" /></p>

<ul>
<li>利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率上的提升(3.0以及4.4以后存在一些使用限制上的差异)。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。</li>
</ul>


<p><img src="/images/android_perf_2_inbitmap_new.png" alt="android_perf_2_inbitmap_new" /></p>

<p>使用inBitmap需要注意几个限制条件：</p>

<ul>
<li>在SDK 11 -> 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。</li>
<li>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。
我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。如下图所示：</li>
</ul>


<p><img src="/images/android_perf_2_inbitmap_pool.png" alt="android_perf_2_inbitmap_pool" /></p>

<p>另外提一点：在2.x的系统上，尽管bitmap是分配在native层，但是还是无法避免被计算到OOM的引用计数器里面。这里提示一下，不少应用会通过反射BitmapFactory.Options里面的inNativeAlloc来达到扩大使用内存的目的，但是如果大家都这么做，对系统整体会造成一定的负面影响，建议谨慎采纳。</p>

<h4>4）避免在onDraw方法里面执行对象的创建</h4>

<p>类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p>

<h4>5）StringBuilder</h4>

<p>在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</p>

<h3>避免对象的内存泄露</h3>

<p>内存对象的泄漏，会导致一些不再使用的对象无法及时释放，这样一方面占用了宝贵的内存空间，很容易导致后续需要分配内存的时候，空闲空间不足而出现OOM。显然，这还使得每级Generation的内存区域可用空间变小，gc就会更容易被触发，容易出现内存抖动，从而引起性能问题。</p>

<p><img src="/images/android_perf_3_leak.png" alt="android_perf_3_leak" /></p>

<p>最新的LeakCanary开源控件，可以很好的帮助我们发现内存泄露的情况，更多关于LeakCanary的介绍，请看这里<a href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a>(中文使用说明<a href="http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/">http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/</a>)。另外也可以使用传统的MAT工具查找内存泄露，请参考这里<a href="http://android-developers.blogspot.pt/2011/03/memory-analysis-for-android.html">http://android-developers.blogspot.pt/2011/03/memory-analysis-for-android.html</a>（便捷的中文资料<a href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/">http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/</a>）</p>

<h4>1）注意Activity的泄漏</h4>

<p>通常来说，Activity的泄漏是内存泄漏里面最严重的问题，它占用的内存多，影响面广，我们需要特别注意以下两种情况导致的Activity泄漏：</p>

<ul>
<li>内部类引用导致Activity的泄漏</li>
</ul>


<p>最典型的场景是Handler导致的Activity泄漏，如果Handler中有延迟的任务或者是等待执行的任务队列过长，都有可能因为Handler继续执行而导致Activity发生泄漏。此时的引用关系链是Looper -> MessageQueue ->  Message -> Handler -> Activity。为了解决这个问题，可以在UI退出之前，执行remove Handler消息队列中的消息与runnable对象。或者是使用Static + WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。</p>

<ul>
<li>Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。</li>
</ul>


<p>内部类引起的泄漏不仅仅会发生在Activity上，其他任何内部类出现的地方，都需要特别留意！我们可以考虑尽量使用static类型的内部类，同时使用WeakReference的机制来避免因为互相引用而出现的泄露。</p>

<h4>2）考虑使用Application Context而不是Activity Context</h4>

<p>对于大部分非必须使用Activity Context的情况（Dialog的Context就必须是Activity Context），我们都可以考虑使用Application Context而不是Activity的Context，这样可以避免不经意的Activity泄露。</p>

<h4>3）注意临时Bitmap对象的及时回收</h4>

<p>虽然在大多数情况下，我们会对Bitmap增加缓存机制，但是在某些时候，部分Bitmap是需要及时回收的。例如临时创建的某个相对比较大的bitmap对象，在经过变换得到新的bitmap对象之后，应该尽快回收原始的bitmap，这样能够更快释放原始bitmap所占用的空间。</p>

<p>需要特别留意的是Bitmap类里面提供的createBitmap()方法：</p>

<p><img src="/images/android_perf_oom_create_bitmap.png" alt="android_perf_oom_create_bitmap.png" /></p>

<p>这个函数返回的bitmap有可能和source bitmap是同一个，在回收的时候，需要特别检查source bitmap与return bitmap的引用是否相同，只有在不等的情况下，才能够执行source bitmap的recycle方法。</p>

<h4>4）注意监听器的注销</h4>

<p>在Android程序里面存在很多需要register与unregister的监听器，我们需要确保在合适的时候及时unregister那些监听器。自己手动add的listener，需要记得及时remove这个listener。</p>

<h4>5）注意缓存容器中的对象泄漏</h4>

<p>有时候，我们为了提高对象的复用性把某些对象放到缓存容器中，可是如果这些对象没有及时从容器中清除，也是有可能导致内存泄漏的。例如，针对2.3的系统，如果把drawable添加到缓存容器，因为drawable与View的强应用，很容易导致activity发生泄漏。而从4.0开始，就不存在这个问题。解决这个问题，需要对2.3系统上的缓存drawable做特殊封装，处理引用解绑的问题，避免泄漏的情况。</p>

<h4>6）注意WebView的泄漏</h4>

<p>Android中的WebView存在很大的兼容性问题，不仅仅是Android系统版本的不同对WebView产生很大的差异，另外不同的厂商出货的ROM里面WebView也存在着很大的差异。更严重的是标准的WebView存在内存泄露的问题，看这里<a href="https://code.google.com/p/android/issues/detail?id=5067">WebView causes memory leak - leaks the parent Activity</a>。所以通常根治这个问题的办法是为WebView开启另外一个进程，通过AIDL与主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。</p>

<h4>7）注意Cursor对象是否及时关闭</h4>

<p>在程序中我们经常会进行查询数据库的操作，但时常会存在不小心使用Cursor之后没有及时关闭的情况。这些Cursor的泄露，反复多次出现的话会对内存管理产生很大的负面影响，我们需要谨记对Cursor对象的及时关闭。</p>

<h3>内存使用策略优化</h3>

<h4>1）谨慎使用large heap</h4>

<p>正如前面提到的，Android设备根据硬件与软件的设置差异而存在不同大小的内存空间，他们为应用程序设置了不同大小的Heap限制阈值。你可以通过调用<code>getMemoryClass()</code>来获取应用的可用Heap大小。在一些特殊的情景下，你可以通过在<code>manifest</code>的<code>application</code>标签下添加<code>largeHeap=true</code>的属性来为应用声明一个更大的heap空间。然后，你可以通过<code>getLargeMemoryClass()</code>来获取到这个更大的heap size阈值。然而，声明得到更大Heap阈值的本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。不要轻易的因为你需要使用更多的内存而去请求一个大的Heap Size。只有当你清楚的知道哪里会使用大量的内存并且知道为什么这些内存必须被保留时才去使用large heap。因此请谨慎使用large heap属性。使用额外的内存空间会影响系统整体的用户体验，并且会使得每次gc的运行时间更长。在任务切换时，系统的性能会大打折扣。另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行<code>getMemoryClass()</code>来检查实际获取到的heap大小。</p>

<h4>2）综合考虑设备内存阈值与其他因素设计合适的缓存大小</h4>

<p>例如，在设计ListView或者GridView的Bitmap LRU缓存的时候，需要考虑的点有：</p>

<ul>
<li>应用程序剩下了多少可用的内存空间?</li>
<li>有多少图片会被一次呈现到屏幕上？有多少图片需要事先缓存好以便快速滑动时能够立即显示到屏幕？</li>
<li>设备的屏幕大小与密度是多少? 一个xhdpi的设备会比hdpi需要一个更大的Cache来hold住同样数量的图片。</li>
<li>不同的页面针对Bitmap的设计的尺寸与配置是什么，大概会花费多少内存？</li>
<li>页面图片被访问的频率？是否存在其中的一部分比其他的图片具有更高的访问频繁？如果是，也许你想要保存那些最常访问的到内存中，或者为不同组别的位图(按访问频率分组)设置多个LruCache容器。</li>
</ul>


<h4>3）onLowMemory()与onTrimMemory()</h4>

<p>Android用户可以随意在不同的应用之间进行快速切换。为了让background的应用能够迅速的切换到forground，每一个background的应用都会占用一定的内存。Android系统会根据当前的系统的内存使用情况，决定回收部分background的应用内存。如果background的应用从暂停状态直接被恢复到forground，能够获得较快的恢复体验，如果background应用是从Kill的状态进行恢复，相比之下就显得稍微有点慢。</p>

<p><img src="/images/android_perf_3_memory_bg_2_for.png" alt="android_perf_3_memory_bg_2_for" /></p>

<ul>
<li><strong>onLowMemory()</strong>：Android系统提供了一些回调来通知当前应用的内存使用情况，通常来说，当所有的background应用都被kill掉的时候，forground应用会收到onLowMemory()的回调。在这种情况下，需要尽快释放当前应用的非必须的内存资源，从而确保系统能够继续稳定运行。</li>
<li><p><strong>onTrimMemory(int)</strong>：Android系统从4.0开始还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调，同时在这个回调里面会传递以下的参数，代表不同的内存使用情况，收到onTrimMemory()回调的时候，需要根据传递的参数类型进行判断，合理的选择释放自身的一些内存占用，一方面可以提高系统的整体运行流畅度，另外也可以避免自己被系统判断为优先需要杀掉的应用。下图介绍了各种不同的回调参数：</p></li>
<li><p><strong>TRIM_MEMORY_UI_HIDDEN</strong>：你的应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键退出应用，导致应用的UI界面完全不可见。这个时候应该释放一些不可见的时候非必须的资源</p></li>
</ul>


<p>当程序正在前台运行的时候，可能会接收到从onTrimMemory()中返回的下面的值之一：</p>

<ul>
<li><strong>TRIM_MEMORY_RUNNING_MODERATE</strong>：你的应用正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。</li>
<li><strong>TRIM_MEMORY_RUNNING_LOW</strong>：你的应用正在运行且没有被列为可杀死的。但是设备正运行于更低内存的状态下，你应该释放不用的资源用来提升系统性能。</li>
<li><strong>TRIM_MEMORY_RUNNING_CRITICAL</strong>：你的应用仍在运行，但是系统已经把LRU Cache中的大多数进程都已经杀死，因此你应该立即释放所有非必须的资源。如果系统不能回收到足够的RAM数量，系统将会清除所有的LRU缓存中的进程，并且开始杀死那些之前被认为不应该杀死的进程，例如那个包含了一个运行态Service的进程。</li>
</ul>


<p>当应用进程退到后台正在被Cached的时候，可能会接收到从onTrimMemory()中返回的下面的值之一：</p>

<ul>
<li><strong>TRIM_MEMORY_BACKGROUND</strong>: 系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的应用进程并不是处于被杀掉的高危险状态，系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的应用的时候才能够迅速恢复。</li>
<li><strong>TRIM_MEMORY_MODERATE</strong>: 系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的。</li>
<li><strong>TRIM_MEMORY_COMPLETE</strong>: 系统正运行于低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的应用恢复状态的资源。</li>
</ul>


<p><img src="/images/android_perf_3_memory_ontrimmemory.png" alt="android_perf_3_memory_ontrimmemory" /></p>

<ul>
<li>因为onTrimMemory()的回调是在API 14才被加进来的，对于老的版本，你可以使用onLowMemory)回调来进行兼容。onLowMemory相当与TRIM_MEMORY_COMPLETE。</li>
<li>请注意：当系统开始清除LRU缓存中的进程时，虽然它首先按照LRU的顺序来执行操作，但是它同样会考虑进程的内存使用量以及其他因素。占用越少的进程越容易被留下来。</li>
</ul>


<h4>4）资源文件需要选择合适的文件夹进行存放</h4>

<p>我们知道<code>hdpi/xhdpi/xxhdpi</code>等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100<em>100的图片，那么根据换算关系，<code>xxhdpi</code>的手机去引用那张图片就会被拉伸到200</em>200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。</p>

<h4>5）Try catch某些大内存分配的操作</h4>

<p>在某些情况下，我们需要事先评估那些可能发生OOM的代码，对于这些可能发生OOM的代码，加入catch机制，可以考虑在catch里面尝试一次降级的内存分配操作。例如decode bitmap的时候，catch到OOM，可以尝试把采样比例再增加一倍之后，再次尝试decode。</p>

<h4>6）谨慎使用static对象</h4>

<p>因为static的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在Android中应该谨慎使用static对象。</p>

<p><img src="/images/android_perf_3_leak_static.png" alt="android_perf_3_leak_static" /></p>

<h4>7）特别留意单例对象中不合理的持有</h4>

<p>虽然单例模式简单实用，提供了很多便利性，但是因为单例的生命周期和应用保持一致，使用不合理很容易出现持有对象的泄漏。</p>

<h4>8）珍惜Services资源</h4>

<p>如果你的应用需要在后台使用service，除非它被触发并执行一个任务，否则其他时候Service都应该是停止状态。另外需要注意当这个service完成任务之后因为停止service失败而引起的内存泄漏。
当你启动一个Service，系统会倾向为了保留这个Service而一直保留Service所在的进程。这使得进程的运行代价很高，因为系统没有办法把Service所占用的RAM空间腾出来让给其他组件，另外Service还不能被Paged out。这减少了系统能够存放到LRU缓存当中的进程数量，它会影响应用之间的切换效率，甚至会导致系统内存使用不稳定，从而无法继续保持住所有目前正在运行的service。
建议使用<a href="http://developer.android.com/reference/android/app/IntentService.html">IntentService</a>，它会在处理完交代给它的任务之后尽快结束自己。更多信息，请阅读<a href="http://developer.android.com/training/run-background-service/index.html">Running in a Background Service</a>。</p>

<h4>9）优化布局层次，减少内存消耗</h4>

<p>越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的View无法实现足够扁平的时候考虑使用自定义View来达到目的。</p>

<h4>10）谨慎使用“抽象”编程</h4>

<p>很多时候，开发者会使用抽象类作为”好的编程实践”，因为抽象能够提升代码的灵活性与可维护性。然而，抽象会导致一个显著的额外内存开销：他们需要同等量的代码用于可执行，那些代码会被mapping到内存中，因此如果你的抽象没有显著的提升效率，应该尽量避免他们。</p>

<h4>11）使用nano protobufs序列化数据</h4>

<p>Protocol buffers是由Google为序列化结构数据而设计的，一种语言无关，平台无关，具有良好的扩展性。类似XML，却比XML更加轻量，快速，简单。如果你需要为你的数据实现序列化与协议化，建议使用nano protobufs。关于更多细节，请参考<a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt">protobuf readme</a>的”Nano version”章节。</p>

<h4>12）谨慎使用依赖注入框架</h4>

<p>使用类似Guice或者RoboGuice等框架注入代码，在某种程度上可以简化你的代码。下面是使用RoboGuice前后的对比图：</p>

<p><img src="/images/android_perf_oom_roboguice_1.png" alt="android_perf_oom_roboguice_1" />
<img src="/images/android_perf_oom_roboguice_2.png" alt="android_perf_oom_roboguice_2" /></p>

<p>使用RoboGuice之后，代码是简化了不少。然而，那些注入框架会通过扫描你的代码执行许多初始化的操作，这会导致你的代码需要大量的内存空间来mapping代码，而且mapped pages会长时间的被保留在内存中。除非真的很有必要，建议谨慎使用这种技术。</p>

<h4>13）谨慎使用多进程</h4>

<p>使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，绝大多数应用都不应该贸然使用多进程，一方面是因为使用多进程会使得代码逻辑更加复杂，另外如果使用不当，它可能反而会导致显著增加内存。当你的应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。</p>

<p>一个典型的例子是创建一个可以长时间后台播放的Music Player。如果整个应用都运行在一个进程中，当后台播放的时候，前台的那些UI资源也没有办法得到释放。类似这样的应用可以切分成2个进程：一个用来操作UI，另外一个给后台的Service。</p>

<h4>14）使用ProGuard来剔除不需要的代码</h4>

<p><a href="http://developer.android.com/tools/help/proguard.html">ProGuard</a>能够通过移除不需要的代码，重命名类，域与方法等等对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够减少mapping代码所需要的内存空间。</p>

<h4>15）谨慎使用第三方libraries</h4>

<p>很多开源的library代码都不是为移动网络环境而编写的，如果运用在移动设备上，并不一定适合。即使是针对Android而设计的library，也需要特别谨慎，特别是在你不知道引入的library具体做了什么事情的时候。例如，其中一个library使用的是nano protobufs, 而另外一个使用的是micro protobufs。这样一来，在你的应用里面就有2种protobuf的实现方式。这样类似的冲突还可能发生在输出日志，加载图片，缓存等等模块里面。另外不要为了1个或者2个功能而导入整个library，如果没有一个合适的库与你的需求相吻合，你应该考虑自己去实现，而不是导入一个大而全的解决方案。</p>

<h4>16）考虑不同的实现方式来优化内存占用</h4>

<p>在某些情况下，设计的某个方案能够快速实现需求，但是这个方案却可能在内存占用上表现的效率不够好。例如：</p>

<p><img src="/images/android_perf_2_waer_animation.png" alt="android_perf_2_waer_animation" /></p>

<p>对于上面这样一个时钟表盘的实现，最简单的就是使用很多张包含指针的表盘图片，使用帧动画实现指针的旋转。但是如果把指针扣出来，单独进行旋转绘制，显然比载入N多张图片占用的内存要少很多。当然这样做，代码复杂度上会有所增加，这里就需要在优化内存占用与实现简易度之间进行权衡了。</p>

<hr />

<p>写在最后：</p>

<ul>
<li>设计风格很大程度上会影响到程序的内存与性能，相对来说，如果大量使用类似Material Design的风格，不仅安装包可以变小，还可以减少内存的占用，渲染性能与加载性能都会有一定的提升。</li>
<li>内存优化并不就是说程序占用的内存越少就越好，如果因为想要保持更低的内存占用，而频繁触发执行gc操作，在某种程度上反而会导致应用性能整体有所下降，这里需要综合考虑做一定的权衡。</li>
<li>Android的内存优化涉及的知识面还有很多：内存管理的细节，垃圾回收的工作原理，如何查找内存泄漏等等都可以展开讲很多。OOM是内存优化当中比较突出的一点，尽量减少OOM的概率对内存优化有着很大的意义。</li>
</ul>


<hr />

<p>参考资料：</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=_CruQY55HOk">Google I/O 2011: Memory management for Android Apps</a></li>
<li><a href="http://developer.android.com/training/articles/memory.html">Managing Your App's Memory</a></li>
<li><a href="http://android-developers.blogspot.com/2009/01/avoiding-memory-leaks.html">Avoiding memory leaks</a></li>
<li><a href="http://hukai.me/android-performance-patterns-season-3/">Android性能优化典范 - 第3季</a></li>
<li><a href="http://hukai.me/android-performance-patterns-season-2/">Android性能优化典范 - 第2季</a></li>
<li><a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a></li>
<li><a href="http://hukai.me/android-performance-memory/">Android性能优化之内存篇</a></li>
<li>其他</li>
</ul>


<p><strong>本文刊登于CSDN《程序员》10月A刊上，如需转载请与CSDN联系</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第3季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-3/"/>
    <updated>2015-08-11T23:53:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-3</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_3.png" alt="android_perf_patterns_season_3" /></p>

<p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范</a>的课程最近更新到第三季了，这次一共12个短视频课程，包括的内容大致有：更高效的ArrayMap容器，使用Android系统提供的特殊容器来避免自动装箱，避免使用枚举类型，注意onLowMemory与onTrimMemory的回调，避免内存泄漏，高效的位置更新操作，重复layout操作的性能影响，以及使用Batching，Prefetching优化网络请求，压缩传输数据等等使用技巧。下面是对这些课程的总结摘要，认知有限，理解偏差的地方请多多交流指正！</p>

<h2>1)Fun with ArrayMaps</h2>

<p>程序内存的管理是否合理高效对应用的性能有着很大的影响，有的时候对容器的使用不当也会导致内存管理效率低下。Android为移动操作系统特意编写了一些更加高效的容器，例如SparseArray，今天要介绍的是一个新的容器，叫做<strong><a href="https://android.googlesource.com/platform/frameworks/base.git/+/master/core/java/android/util/ArrayMap.java">ArrayMap</a></strong>。</p>

<p>我们经常会使用到HashMap这个容器，它非常好用，但是却很占用内存。下图演示了HashMap的简要工作原理：</p>

<p><img src="/images/android_perf_3_arraymap_key_value.png" alt="android_perf_3_arraymap_key_value" /></p>

<p>为了解决HashMap更占内存的弊端，Android提供了内存效率更高的<strong>ArrayMap</strong>。它内部使用两个数组进行工作，其中一个数组记录key hash过后的顺序列表，另外一个数组按key的顺序记录Key-Value值，如下图所示：</p>

<!-- More -->


<p><img src="/images/android_perf_3_arraymap_two_array.png" alt="android_perf_3_arraymap_two_array" /></p>

<p>当你想获取某个value的时候，ArrayMap会计算输入key转换过后的hash值，然后对hash数组使用二分查找法寻找到对应的index，然后我们可以通过这个index在另外一个数组中直接访问到需要的键值对。如果在第二个数组键值对中的key和前面输入的查询key不一致，那么就认为是发生了碰撞冲突。为了解决这个问题，我们会以该key为中心点，分别上下展开，逐个去对比查找，直到找到匹配的值。如下图所示：</p>

<p><img src="/images/android_perf_3_arraymap_binary_search.png" alt="android_perf_3_arraymap_binary_search" /></p>

<p>随着数组中的对象越来越多，查找访问单个对象的花费也会跟着增长，这是在内存占用与访问时间之间做权衡交换。</p>

<p>既然ArrayMap中的内存占用是连续不间断的，那么它是如何处理插入与删除操作的呢？请看下图所示，演示了Array的特性：</p>

<p><img src="/images/android_perf_3_arraymap_del.png" alt="android_perf_3_arraymap_del" /></p>

<p><img src="/images/android_perf_3_arraymap_add.png" alt="android_perf_3_arraymap_add" /></p>

<p>很明显，ArrayMap的插入与删除的效率是不够高的，但是如果数组的列表只是在一百这个数量级上，则完全不用担心这些插入与删除的效率问题。HashMap与ArrayMap之间的内存占用效率对比图如下：</p>

<p><img src="/images/android_perf_3_arraymap_memory_compare.png" alt="android_perf_3_arraymap_memory_compare" /></p>

<p>与HashMap相比，ArrayMap在循环遍历的时候也更加简单高效，如下图所示：</p>

<p><img src="/images/android_perf_3_arraymap_list.png" alt="android_perf_3_arraymap_list" /></p>

<p>前面演示了很多ArrayMap的优点，但并不是所有情况下都适合使用ArrayMap，我们应该在满足下面2个条件的时候才考虑使用ArrayMap：</p>

<ul>
<li>对象个数的数量级最好是千以内</li>
<li>数据组织形式包含Map结构</li>
</ul>


<p>我们需要学会在特定情形下选择相对更加高效的实现方式。</p>

<h2>2)Beware Autoboxing</h2>

<p>有时候性能问题也可能是因为那些不起眼的小细节引起的，例如在代码中不经意的“自动装箱”。我们知道基础数据类型的大小：boolean(8 bits), int(32 bits), float(32 bits)，long(64 bits)，为了能够让这些基础数据类型在大多数Java容器中运作，会需要做一个autoboxing的操作，转换成Boolean，Integer，Float等对象，如下演示了循环操作的时候是否发生autoboxing行为的差异：</p>

<p><img src="/images/android_perf_3_autoboxing_for.png" alt="android_perf_3_autoboxing_for" /></p>

<p><img src="/images/android_perf_3_autoboxing_perf.png" alt="android_perf_3_autoboxing_perf" /></p>

<p>Autoboxing的行为还经常发生在类似HashMap这样的容器里面，对HashMap的增删改查操作都会发生了大量的autoboxing的行为。</p>

<p><img src="/images/android_perf_3_autoboxing_hashmap.png" alt="android_perf_3_autoboxing_hashmap" /></p>

<p>为了避免这些autoboxing带来的效率问题，Android特地提供了一些如下的Map容器用来替代HashMap，不仅避免了autoboxing，还减少了内存占用：</p>

<p><img src="/images/android_perf_3_autoboxing_sparse.png" alt="android_perf_3_autoboxing_sparse" /></p>

<h2>3)SparseArray Family Ties</h2>

<p>为了避免HashMap的autoboxing行为，Android系统提供了SparseBoolMap，SparseIntMap，SparseLongMap，LongSparseMap等容器。关于这些容器的基本原理请参考前面的ArrayMap的介绍，另外这些容器的使用场景也和ArrayMap一致，需要满足数量级在千以内，数据组织形式需要包含Map结构。</p>

<h2>4)The price of ENUMs</h2>

<p>在StackOverFlow等问答社区常常出现关于在Android系统里面使用枚举类型的性能讨论，关于这一点，Android官方的Training课程里面有下面这样一句话：</p>

<blockquote><p>Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</p></blockquote>

<p><img src="/images/android_perf_3_enum.png" alt="android_perf_3_enum" /></p>

<p>关于enum的效率，请看下面的讨论。假设我们有这样一份代码，编译之后的dex大小是2556 bytes，在此基础之上，添加一些如下代码，这些代码使用普通static常量相关作为判断值：</p>

<p><img src="/images/android_perf_3_enum_static.png" alt="android_perf_3_enum_static" /></p>

<p>增加上面那段代码之后，编译成dex的大小是2680 bytes，相比起之前的2556 bytes只增加124 bytes。假如换做使用enum，情况如下：</p>

<p><img src="/images/android_perf_3_enum_enum.png" alt="android_perf_3_enum_enum" /></p>

<p>使用enum之后的dex大小是4188 bytes，相比起2556增加了1632 bytes，增长量是使用static int的13倍。不仅仅如此，使用enum，运行时还会产生额外的内存占用，如下图所示：</p>

<p><img src="/images/android_perf_3_enum_memory.png" alt="android_perf_3_enum_memory" /></p>

<p>Android官方强烈建议不要在Android程序里面使用到enum。</p>

<h2>5)Trimming and Sharing Memory</h2>

<p>Android系统的一大特色是多任务，用户可以随意在不同的app之间进行快速切换。为了确保你的应用在这种复杂的多任务环境中正常运行，我们需要了解下面的知识。</p>

<p>为了让background的应用能够迅速的切换到forground，每一个background的应用都会占用一定的内存。Android系统会根据当前的系统内存使用情况，决定回收部分background的应用内存。如果background的应用从暂停状态直接被恢复到forground，能够获得较快的恢复体验，如果background应用是从Kill的状态进行恢复，就会显得稍微有点慢。</p>

<p><img src="/images/android_perf_3_memory_bg_2_for.png" alt="android_perf_3_memory_bg_2_for" /></p>

<p>Android系统提供了一些回调来通知应用的内存使用情况，通常来说，当所有的background应用都被kill掉的时候，forground应用会收到<strong>onLowMemory()</strong>的回调。在这种情况下，需要尽快释放当前应用的非必须内存资源，从而确保系统能够稳定继续运行。Android系统还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调，同时在这个回调里面会传递以下的参数，代表不同的内存使用情况，下图介绍了各种不同的回调参数：</p>

<p><img src="/images/android_perf_3_memory_ontrimmemory.png" alt="android_perf_3_memory_ontrimmemory" /></p>

<p>关于每个参数的更多介绍，请参考这里 <a href="http://hukai.me/android-training-managing_your_app_memory/">http://hukai.me/android-training-managing_your_app_memory/</a>，另外onTrimMemory()的回调可以发生在Application，Activity，Fragment，Service，Content Provider。</p>

<p>从Android 4.4开始，ActivityManager提供了<strong>isLowRamDevice()</strong>的API，通常指的是Heap Size低于512M或者屏幕大小&lt;=800*480的设备。</p>

<h2>6)DO NOT LEAK VIEWS</h2>

<p>内存泄漏的概念，下面一张图演示下：</p>

<p><img src="/images/android_perf_3_leak.png" alt="android_perf_3_leak" /></p>

<p>通常来说，View会保持Activity的引用，Activity同时还和其他内部对象也有可能保持引用关系。当屏幕发生旋转的时候，activity很容易发生泄漏，这样的话，里面的view也会发生泄漏。Activity以及view的泄漏是非常严重的，为了避免出现泄漏，请特别留意以下的规则：</p>

<h3>6.1)避免使用异步回调</h3>

<p>异步回调被执行的时间不确定，很有可能发生在activity已经被销毁之后，这不仅仅很容易引起crash，还很容易发生内存泄露。</p>

<p><img src="/images/android_perf_3_leak_asyncback.png" alt="android_perf_3_leak_asyncback" /></p>

<h3>6.2)避免使用Static对象</h3>

<p>因为static的生命周期过长，使用不当很可能导致leak，在Android中应该尽量避免使用static对象。</p>

<p><img src="/images/android_perf_3_leak_static.png" alt="android_perf_3_leak_static" /></p>

<h3>6.3)避免把View添加到没有清除机制的容器里面</h3>

<p>假如把view添加到<a href="http://stackoverflow.com/questions/5511279/what-is-a-weakhashmap-and-when-to-use-it">WeakHashMap</a>，如果没有执行清除操作，很可能会导致泄漏。</p>

<p><img src="/images/android_perf_3_leak_map.png" alt="android_perf_3_leak_map" /></p>

<h2>7)Location &amp; Battery Drain</h2>

<p>开启定位功能是一个相对来说比较耗电的操作，通常来说，我们会使用类似下面这样的代码来发出定位请求：</p>

<p><img src="/images/android_perf_3_location_request.png" alt="android_perf_3_location_request" /></p>

<p>上面演示中有一个方法是<strong>setInterval()</strong>指的意思是每隔多长的时间获取一次位置更新，时间相隔越短，自然花费的电量就越多，但是时间相隔太长，又无法及时获取到更新的位置信息。其中存在的一个优化点是，我们可以通过判断返回的位置信息是否相同，从而决定设置下次的更新间隔是否增加一倍，通过这种方式可以减少电量的消耗，如下图所示：</p>

<p><img src="/images/android_perf_3_location_reduce.png" alt="android_perf_3_location_reduce" /></p>

<p>在位置请求的演示代码中还有一个方法是<strong>setFastestInterval()</strong>，因为整个系统中很可能存在其他的应用也在请求位置更新，那些应用很有可能设置的更新间隔时间很短，这种情况下，我们就可以通过setFestestInterval的方法来过滤那些过于频繁的更新。</p>

<p>通过GPS定位服务相比起使用网络进行定位更加的耗电，但是也相对更加精准一些，他们的图示关系如下：</p>

<p><img src="/images/android_perf_3_location_provider.png" alt="android_perf_3_location_provider" /></p>

<p>为了提供不同精度的定位需求，同时屏蔽实现位置请求的细节，Android提供了下面4种不同精度与耗电量的参数给应用进行设置调用，应用只需要决定在适当的场景下使用对应的参数就好了，通过LocationRequest.setPriority()方法传递下面的参数就好了。</p>

<p><img src="/images/android_perf_3_location_accuracy.png" alt="android_perf_3_location_accuracy" /></p>

<h2>8)Double Layout Taxation</h2>

<p>布局中的任何一个View一旦发生一些属性变化，都可能引起很大的连锁反应。例如某个button的大小突然增加一倍，有可能会导致兄弟视图的位置变化，也有可能导致父视图的大小发生改变。当大量的layout()操作被频繁调用执行的时候，就很可能引起丢帧的现象。</p>

<p><img src="/images/android_perf_3_layout_double.png" alt="android_perf_3_layout_double" /></p>

<p>例如，在RelativeLayout中，我们通常会定义一些类似alignTop，alignBelow等等属性，如图所示：</p>

<p><img src="/images/android_perf_3_layout_relative.png" alt="android_perf_3_layout_relative" /></p>

<p>为了获得视图的准确位置，需要经过下面几个阶段。首先子视图会触发计算自身位置的操作，然后RelativeLayout使用前面计算出来的位置信息做边界的调整的操作，如下面两张图所示：</p>

<p><img src="/images/android_perf_3_layout_first_cal.png" alt="android_perf_3_layout_first_cal" /></p>

<p><img src="/images/android_perf_3_layout_first_adjust.png" alt="android_perf_3_layout_first_adjust" /></p>

<p>经历过上面2个步骤，relativeLayout会立即触发第二次layout()的操作来确定所有子视图的最终位置与大小信息。</p>

<p>除了RelativeLayout会发生两次layout操作之外，LinearLayout也有可能触发两次layout操作，通常情况下LinearLayout只会发生一次layout操作，可是一旦调用了measureWithLargetChild()方法就会导致触发两次layout的操作。另外，通常来说，GridLayout会自动预处理子视图的关系来避免两次layout，可是如果GridLayout里面的某些子视图使用了weight等复杂的属性，还是会导致重复的layout操作。</p>

<p>如果只是少量的重复layout本身并不会引起严重的性能问题，但是如果它们发生在布局的根节点，或者是ListView里面的某个ListItem，这样就会引起比较严重的性能问题。如下图所示：</p>

<p><img src="/images/android_perf_3_layout_hierachy.png" alt="android_perf_3_layout_hierachy" /></p>

<p>我们可以使用Systrace来跟踪特定的某段操作，如果发现了疑似丢帧的现象，可能就是因为重复layout引起的。通常我们无法避免重复layout，在这种情况下，我们应该尽量保持View Hierarchy的层级比较浅，这样即使发生重复layout，也不会因为布局的层级比较深而增大了重复layout的倍数。另外还有一点需要特别注意，在任何时候都请避免调用<strong>requestLayout()</strong>的方法，因为一旦调用了requestLayout，会导致该layout的所有父节点都发生重新layout的操作。</p>

<p><img src="/images/android_perf_3_layout_request.png" alt="android_perf_3_layout_request" /></p>

<h2>9)Network Performance 101</h2>

<p>在性能优化第一季与第二季的课程里面都介绍过，网络请求的操作是非常耗电的，其中在移动蜂窝网络情况下执行网络数据的请求则尤其比较耗电。关于如何减少移动网络下的网络请求的耗电量，有两个重要的原则需要遵守：第一个是减少移动网络被激活的时间与次数，第二个是压缩传输数据。</p>

<h3>9.1)减少移动网络被激活的时间与次数</h3>

<p>通常来说，发生网络行为可以划分为如下图所示的三种类型，一个是用户主动触发的请求，另外被动接收服务器的返回数据，最后一个是数据上报，行为上报，位置更新等等自定义的后台操作。</p>

<p><img src="/images/android_perf_3_network_three_type.png" alt="android_perf_3_network_three_type" /></p>

<p>我们绝对坚决肯定不应该使用Polling(轮询)的方式去执行网络请求，这样不仅仅会造成严重的电量消耗，还会浪费许多网络流量，例如：</p>

<p><img src="/images/android_perf_3_network_polling.png" alt="android_perf_3_network_polling" /></p>

<p>Android官方推荐使用<a href="https://developers.google.com/cloud-messaging/">Google Cloud Messaging</a>(在大陆，然并卵)，这个框架会帮助把更新的数据推送给手机客户端，效率极高！我们应该遵循下面的规则来处理数据同步的问题：</p>

<p>首先，我们应该使用回退机制来避免固定频繁的同步请求，例如，在发现返回数据相同的情况下，推迟下次的请求时间，如下图所示：</p>

<p><img src="/images/android_perf_3_network_backoff.png" alt="android_perf_3_network_backoff" /></p>

<p>其次，我们还可以使用<strong>Batching</strong>(批处理)的方式来集中发出请求，避免频繁的间隔请求，如下图所示：</p>

<p><img src="/images/android_perf_3_network_batching.png" alt="android_perf_3_network_batching" /></p>

<p>最后，我们还可以使用<strong>Prefetching</strong>(预取)的技术提前把一些数据拿到，避免后面频繁再次发起网络请求，如下图所示：</p>

<p><img src="/images/android_perf_3_network_prefetching.png" alt="android_perf_3_network_prefetching" /></p>

<p>Google Play Service中提供了一个叫做<a href="https://developers.google.com/cloud-messaging/network-manager">GCMNetworkManager</a>的类来帮助我们实现上面的那些功能，我们只需要调用对应的API，设置一些简单的参数，其余的工作就都交给Google来帮我们实现了。</p>

<p><img src="/images/android_perf_3_network_gcm_network_manager.png" alt="android_perf_3_network_gcm_network_manager" /></p>

<h3>9.2)压缩传输数据</h3>

<p>关于压缩传输数据，我们可以学习以下的一些课程(真的够喝好几壶了)：</p>

<ul>
<li><a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H">CompressorHead</a>：这系列的课程会介绍压缩的基本概念以及一些常见的压缩算法知识。</li>
<li><a href="http://www.html5rocks.com/en/tutorials/speed/img-compression/">Image Compression</a>：介绍关于图片的压缩知识。</li>
<li><a href="http://www.gdcvault.com/play/1020682/Texture-Wranglin-Getting-your-Android">Texture Wranglin</a>：介绍了游戏开发相关的知识。</li>
<li><a href="https://www.youtube.com/watch?v=P7riQin9Bfo&amp;feature=iv&amp;src_vid=l5mE3Tpjejs&amp;annotation_id=annotation_3146342489">Grabby</a>：介绍了游戏开发相关的知识。</li>
<li><a href="https://www.youtube.com/watch?v=whGwm0Lky2s&amp;feature=iv&amp;src_vid=l5mE3Tpjejs&amp;annotation_id=annotation_1270272007">Gzip is not enough</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/speed/txt-compression/">Text Compression</a></li>
<li><a href="https://www.youtube.com/watch?v=iQTxMkSJ1dQ&amp;feature=iv&amp;src_vid=l5mE3Tpjejs&amp;annotation_id=annotation_632816183">FlatBuffers</a></li>
</ul>


<h2>10)Effective Network Batching</h2>

<p>在性能优化课程的第一季与第二季里面，我们都有提到过下面这样一个网络请求与电量消耗的示意图：</p>

<p><img src="/images/android_perf_3_batching_networking.png" alt="android_perf_3_batching_networking" /></p>

<p>发起网络请求与接收返回数据都是比较耗电的，在网络硬件模块被激活之后，会继续保持几十秒的电量消耗，直到没有新的网络操作行为之后，才会进入休眠状态。前面一个段落介绍了使用Batching的技术来捆绑网络请求，从而达到减少网络请求的频率。那么如何实现Batching技术呢？通常来说，我们可以会把那些发出的网络请求，先暂存到一个PendingQueue里面，等到条件合适的时候再触发Queue里面的网络请求。</p>

<p><img src="/images/android_perf_3_batching_queue.png" alt="android_perf_3_batching_queue" /></p>

<p>可是什么时候才算是条件合适了呢？最简单粗暴的，例如我们可以在Queue大小到10的时候触发任务，也可以是当手机开始充电，或者是手机连接到WiFi等情况下才触发队列中的任务。手动编写代码去实现这些功能会比较复杂繁琐，Google为了解决这个问题，为我们提供了GCMNetworkManager来帮助实现那些功能，仅仅只需要调用API，设置触发条件，然后就OK了。</p>

<h2>11)Optimizing Network Request Frequencies</h2>

<p>前面的段落已经提到了应该减少网络请求的频率，这是为了减少电量的消耗。我们可以使用Batching，Prefetching的技术来避免频繁的网络请求。Google提供了GCMNetworkManager来帮助开发者实现那些功能，通过提供的API，我们可以选择在接入WiFi，开始充电，等待移动网络被激活等条件下再次激活网络请求。</p>

<h2>12)Effective Prefetching</h2>

<p>假设我们有这样的一个场景，最开始网络请求了一张图片，隔了10秒需要请求另外一张图片，再隔6秒会请求第三张图片，如下图所示：</p>

<p><img src="/images/android_perf_3_prefetching.png" alt="android_perf_3_prefetching" /></p>

<p>类似上面的情况会频繁触发网络请求，但是如果我们能够预先请求后续可能会使用到网络资源，避免频繁的触发网络请求，这样就能够显著的减少电量的消耗。可是预先获取多少数据量是很值得考量的，因为如果预取数据量偏少，就起不到减少频繁请求的作用，可是如果预取数据过多，就会造成资源的浪费。</p>

<p><img src="/images/android_perf_3_prefetching_over.png" alt="android_perf_3_prefetching_over" /></p>

<p>我们可以参考在WiFi，4G，3G等不同的网络下设计不同大小的预取数据量，也可以是按照图片数量或者操作时间来作为阀值。这需要我们需要根据特定的场景，不同的网络情况设计合适的方案。</p>

<hr />

<p>首发于CSDN：<a href="http://www.csdn.net/article/2015-08-12/2825447-android-performance-patterns-season-3">Android性能优化典范（三）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范 - 第2季]]></title>
    <link href="http://hukai.me/android-performance-patterns-season-2/"/>
    <updated>2015-04-29T12:32:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns-season-2</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns_season_2.png" alt="android_perf_patterns_season_2" /></p>

<p>Google前几天刚发布了<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范第2季</a>的课程，一共20个短视频，包括的内容大致有：电量优化，网络优化，Wear上如何做优化，使用对象池来提高效率，LRU Cache，Bitmap的缩放，缓存，重用，PNG压缩，自定义View的性能，提升设置alpha之后View的渲染性能，以及Lint，StictMode等等工具的使用技巧。
下面是对这些课程的总结摘要，认知有限，理解偏差的地方请多多指教！</p>

<h2>1)Battery Drain and Networking</h2>

<p>对于手机程序，网络操作相对来说是比较耗电的行为。优化网络操作能够显著节约电量的消耗。在性能优化第1季里面有提到过，手机硬件的各个模块的耗电量是不一样的，其中移动蜂窝模块对电量消耗是比较大的，另外蜂窝模块在不同工作强度下，对电量的消耗也是有差异的。当程序想要执行某个网络请求之前，需要先唤醒设备，然后发送数据请求，之后等待返回数据，最后才慢慢进入休眠状态。这个流程如下图所示：</p>

<p><img src="/images/android_perf_2_network_request_mode.png" alt="android_perf_2_network_request_mode" /></p>

<!-- More -->


<p>在上面那个流程中，蜂窝模块的电量消耗差异如下图所示：</p>

<p><img src="/images/android_perf_2_battery_drain_mode.png" alt="android_perf_2_battery_drain_mode" /></p>

<p>从图示中可以看到，激活瞬间，发送数据的瞬间，接收数据的瞬间都有很大的电量消耗，所以，我们应该从如何传递网络数据以及何时发起网络请求这两个方面来着手优化。</p>

<h4>1.1)何时发起网络请求</h4>

<p>首先我们需要区分哪些网络请求是需要及时返回结果的，哪些是可以延迟执行的。例如，用户主动下拉刷新列表，这种行为需要立即触发网络请求，并等待数据返回。但是对于上传用户操作的数据，同步程序设置等等行为则属于可以延迟的行为。我们可以通过Battery Historian这个工具来查看关于移动蜂窝模块的电量消耗（关于这部分的细节，请点击<a href="http://hukai.me/android-performance-battery/">Android性能优化之电量篇</a>）。在Mobile Radio那一行会显示蜂窝模块的电量消耗情况，红色的部分代表模块正在工作，中间的间隔部分代表模块正在休眠状态，如果看到有一段区间，红色与间隔频繁的出现，那就说明这里有可以优化的行为。如下图所示：</p>

<p><img src="/images/android_perf_2_battery_mobile_radio.png" alt="android_perf_2_battery_mobile_radio" /></p>

<p>对于上面可以优化的部分，我们可以有针对性的把请求行为捆绑起来，延迟到某个时刻统一发起请求。如下图所示：</p>

<p><img src="/images/android_perf_2_battery_batch_delay.png" alt="android_perf_2_battery_batch_delay" /></p>

<p>经过上面的优化之后，我们再回头使用Battery Historian导出电量消耗图，可以看到唤醒状态与休眠状态是连续大块间隔的，这样的话，总体电量的消耗就会变得更少。</p>

<p><img src="/images/android_perf_2_battery_mobile_radio_2.png" alt="android_perf_2_battery_mobile_radio_2" /></p>

<p>当然，我们甚至可以把请求的任务延迟到手机网络切换到WiFi，手机处于充电状态下再执行。在前面的描述过程中，我们会遇到的一个难题是如何把网络请求延迟，并批量进行执行。还好，Android提供了<a href="http://developer.android.com/intl/zh-cn/reference/android/app/job/JobScheduler.html">JobScheduler</a>来帮助我们达成这个目标。</p>

<h4>1.2)如何传递网络数据</h4>

<p>关于这部分主要会涉及到Prefetch(预取)与Compressed(压缩)这两个技术。对于Prefetch的使用，我们需要预先判断用户在此次操作之后，后续零散的请求是否很有可能会马上被触发，可以把后面5分钟有可能会使用到的零散请求都一次集中执行完毕。对于Compressed的使用，在上传与下载数据之前，使用CPU对数据进行压缩与解压，可以很大程度上减少网络传输的时间。</p>

<p>想要知道我们的应用程序中网络请求发生的时间，每次请求的数据量等等信息，可以通过Android Studio中的<a href="http://developer.android.com/intl/zh-cn/tools/debugging/ddms.html#network">Networking Traffic Tool</a>来查看详细的数据，如下图所示：</p>

<p><img src="/images/android_perf_2_battery_network_tracking.png" alt="android_perf_2_battery_network_tracking" /></p>

<h2>2)Wear &amp; Sensors</h2>

<p>在Android Wear上会大量的使用Sensors来实现某些特殊功能，如何在尽量节约电量的前提下利用好Sensor会是我们需要特别注意的问题。下面会介绍一些在Android Wear上的最佳实践典范。</p>

<p>尽量减少刷新请求，例如我们可以在不需要某些数据的时候尽快注销监听，减小刷新频率，对Sensor的数据做批量处理等等。那么如何做到这些优化呢？</p>

<ul>
<li>首先我们需要尽量使用Android平台提供的既有运动数据，而不是自己去实现监听采集数据，因为大多数Android Watch自身记录Sensor数据的行为是有经过做电量优化的。</li>
<li>其次在Activity不需要监听某些Sensor数据的时候需要尽快释放监听注册。</li>
<li>还有我们需要尽量控制更新的频率，仅仅在需要刷新显示数据的时候才触发获取最新数据的操作。</li>
<li>另外我们可以针对Sensor的数据做批量处理，待数据累积一定次数或者某个程度的时候才更新到UI上。</li>
<li>最后当Watch与Phone连接起来的时候，可以把某些复杂操作的事情交给Phone来执行，Watch只需要等待返回的结果。</li>
</ul>


<p>更对关于Sensors的知识，可以点击<a href="https://www.youtube.com/watch?v=82M8DmFz4P8&amp;index=2&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">这里</a></p>

<h2>3)Smooth Android Wear Animation</h2>

<p>Android Material Design风格的应用采用了大量的动画来进行UI切换，优化动画的性能不仅能够提升用户体验还可以减少电量的消耗，下面会介绍一些简单易行的方法。</p>

<p>在Android里面一个相对操作比较繁重的事情是对Bitmap进行旋转，缩放，裁剪等等。例如在一个圆形的钟表图上，我们把时钟的指针抠出来当做单独的图片进行旋转会比旋转一张完整的圆形图的所形成的帧率要高56%。</p>

<p><img src="/images/android_perf_2_waer_animation.png" alt="android_perf_2_waer_animation" /></p>

<p>另外尽量减少每次重绘的元素可以极大的提升性能，假如某个钟表界面上有很多需要显示的复杂组件，我们可以把这些组件做拆分处理，例如把背景图片单独拎出来设置为一个独立的View，通过setLayerType()方法使得这个View强制用Hardware来进行渲染。至于界面上哪些元素需要做拆分，他们各自的更新频率是多少，需要有针对性的单独讨论。</p>

<p>如何使用Systrace等工具来查看某些View的渲染性能，在前面的章节里面有提到过，感兴趣的可以点击<a href="http://hukai.me/android-performance-render/">这里</a></p>

<p>对于大多数应用中的动画，我们会使用PropertyAnimation或者ViewAnimation来操作实现，Android系统会自动对这些Animation做一定的优化处理，在Android上面学习到的大多数性能优化的知识同样也适用于Android Wear。</p>

<p>想要获取更多关于Android Wear中动画效果的优化，请点击<a href="http://developer.android.com/samples/WatchFace/index.html">WatchFace</a>这个范例。</p>

<h2>4)Android Wear Data Batching</h2>

<p>在Android Training里面有关于Wear上面如何利用Wearable API与Phone进行沟通协作的课程(详情请点击<a href="http://developer.android.com/training/wearables/data-layer/index.html">这里</a>)。因为Phone的CPU与电量都比Wear要强大，另外Phone还可以直接接入网络，而Wear要接入网络则相对更加困难，所以我们在开发Wear应用的时候需要尽量做到把复杂的操作交给Phone来执行。例如我们可以让Phone来获取天气信息，然后把数据返回Wear进行显示。更进一步，在之前的性能优化课程里面我们有学习过如何使用JobScheduler来延迟批量处理任务，假设Phone收到来自Wear的其中一个任务是每隔5分钟检查一次天气情况，那么Phone使用JobScheduler执行检查天气任务之后，先判断这次返回的结果和之前是否有差异，仅仅当天气发生变化的时候，才有必要把结果通知到Wear，或者仅仅把变化的某一项数据通知给Wear，这样可以更大程度上减少Wear的电量消耗。</p>

<p>下面我们总结一下如何优化Wear的性能与电量：</p>

<ul>
<li>仅仅在真正需要刷新界面的时候才发出请求</li>
<li>尽量把计算复杂操作的任务交给Phone来处理</li>
<li>Phone仅仅在数据发生变化的时候才通知到Wear</li>
<li>把零碎的数据请求捆绑一起再进行操作</li>
</ul>


<h2>5)Object Pools</h2>

<p>在程序里面经常会遇到的一个问题是短时间内创建大量的对象，导致内存紧张，从而触发GC导致性能问题。对于这个问题，我们可以使用对象池技术来解决它。通常对象池中的对象可能是bitmaps，views，paints等等。关于对象池的操作原理，不展开述说了，请看下面的图示：</p>

<p><img src="/images/android_perf_2_object_pool.png" alt="android_perf_2_object_pool" /></p>

<p>使用对象池技术有很多好处，它可以避免内存抖动，提升性能，但是在使用的时候有一些内容是需要特别注意的。通常情况下，初始化的对象池里面都是空白的，当使用某个对象的时候先去对象池查询是否存在，如果不存在则创建这个对象然后加入对象池，但是我们也可以在程序刚启动的时候就事先为对象池填充一些即将要使用到的数据，这样可以在需要使用到这些对象的时候提供更快的首次加载速度，这种行为就叫做<strong>预分配</strong>。使用对象池也有不好的一面，程序员需要手动管理这些对象的分配与释放，所以我们需要慎重地使用这项技术，避免发生对象的内存泄漏。为了确保所有的对象能够正确被释放，我们需要保证加入对象池的对象和其他外部对象没有互相引用的关系。</p>

<h2>6)To Index or Iterate?</h2>

<p>遍历容器是编程里面一个经常遇到的场景。在Java语言中，使用Iterate是一个比较常见的方法。可是在Android开发团队中，大家却尽量避免使用Iterator来执行遍历操作。下面我们看下在Android上可能用到的三种不同的遍历方法：</p>

<p><img src="/images/android_perf_2_iterate_1.png" alt="android_perf_2_iterate_1" /></p>

<p><img src="/images/android_perf_2_iterate_for_loop.png" alt="android_perf_2_iterate_for_loop" /></p>

<p><img src="/images/android_perf_2_iterate_simple_loop.png" alt="android_perf_2_iterate_simple_loop" /></p>

<p>使用上面三种方式在同一台手机上，使用相同的数据集做测试，他们的表现性能如下所示：</p>

<p><img src="/images/android_perf_2_iterate_result.png" alt="android_perf_2_iterate_result" /></p>

<p>从上面可以看到for index的方式有更好的效率，但是因为不同平台编译器优化各有差异，我们最好还是针对实际的方法做一下简单的测量比较好，拿到数据之后，再选择效率最高的那个方式。</p>

<h2>7)The Magic of LRU Cache</h2>

<p>这小节我们要讨论的是缓存算法，在Android上面最常用的一个缓存算法是LRU(Least Recently Use)，关于LRU算法，不展开述说，用下面一张图演示下含义：</p>

<p><img src="/images/android_perf_2_lru_mode.png" alt="android_perf_2_lru_mode" /></p>

<p>LRU Cache的基础构建用法如下：</p>

<p><img src="/images/android_perf_2_lru_key_value.png" alt="android_perf_2_lru_key_value" /></p>

<p>为了给LRU Cache设置一个比较合理的缓存大小值，我们通常是用下面的方法来做界定的：</p>

<p><img src="/images/android_perf_2_lru_size.png" alt="android_perf_2_lru_size" /></p>

<p>使用LRU Cache时为了能够让Cache知道每个加入的Item的具体大小，我们需要Override下面的方法：</p>

<p><img src="/images/android_perf_2_lru_sizeof.png" alt="android_perf_2_lru_sizeof" /></p>

<p>使用LRU Cache能够显著提升应用的性能，可是也需要注意LRU Cache中被淘汰对象的回收，否者会引起严重的内存泄露。</p>

<h2>8)Using LINT for Performance Tips</h2>

<p>Lint是Android提供的一个静态扫描应用源码并找出其中的潜在问题的一个强大的工具。</p>

<p><img src="/images/android_perf_2_lint_overview.png" alt="android_perf_2_lint_overview" /></p>

<p>例如，如果我们在onDraw方法里面执行了new对象的操作，Lint就会提示我们这里有性能问题，并提出对应的建议方案。Lint已经集成到Android Studio中了，我们可以手动去触发这个工具，点击工具栏的Analysis -> Inspect Code，触发之后，Lint会开始工作，并把结果输出到底部的工具栏，我们可以逐个查看原因并根据指示做相应的优化修改。</p>

<p>Lint的功能非常强大，他能够扫描各种问题。当然我们可以通过Android Studio设置找到Lint，对Lint做一些定制化扫描的设置，可以选择忽略掉那些不想Lint去扫描的选项，我们还可以针对部分扫描内容修改它的提示优先级。</p>

<p>建议把与内存有关的选项中的严重程度标记为红色的Error，对于Layout的性能问题标记为黄色Warning。</p>

<h2>9)Hidden Cost of Transparency</h2>

<p>这小节会介绍如何减少透明区域对性能的影响。通常来说，对于不透明的View，显示它只需要渲染一次即可，可是如果这个View设置了alpha值，会至少需要渲染两次。原因是包含alpha的view需要事先知道混合View的下一层元素是什么，然后再结合上层的View进行Blend混色处理。</p>

<p>在某些情况下，一个包含alpha的View有可能会触发改View在HierarchyView上的父View都被额外重绘一次。下面我们看一个例子，下图演示的ListView中的图片与二级标题都有设置透明度。</p>

<p><img src="/images/android_perf_2_trans_listview.png" alt="android_perf_2_trans_listview" /></p>

<p>大多数情况下，屏幕上的元素都是由后向前进行渲染的。在上面的图示中，会先渲染背景图(蓝，绿，红)，然后渲染人物头像图。如果后渲染的元素有设置alpha值，那么这个元素就会和屏幕上已经渲染好的元素做blend处理。很多时候，我们会给整个View设置alpha的来达到fading的动画效果，如果我们图示中的ListView做alpha逐渐减小的处理，我们可以看到ListView上的TextView等等组件会逐渐融合到背景色上。但是在这个过程中，我们无法观察到它其实已经触发了额外的绘制任务，我们的目标是让整个View逐渐透明，可是期间ListView在不停的做Blending的操作，这样会导致不少性能问题。</p>

<p>如何渲染才能够得到我们想要的效果呢？我们可以先按照通常的方式把View上的元素按照从后到前的方式绘制出来，但是不直接显示到屏幕上，而是使用GPU预处理之后，再又GPU渲染到屏幕上，GPU可以对界面上的原始数据直接做旋转，设置透明度等等操作。使用GPU进行渲染，虽然第一次操作相比起直接绘制到屏幕上更加耗时，可是一旦原始纹理数据生成之后，接下去的操作就比较省时省力。</p>

<p><img src="/images/android_perf_2_trans_hw_layer.png" alt="android_perf_2_trans_hw_layer" /></p>

<p>如何才能够让GPU来渲染某个View呢？我们可以通过setLayerType的方法来指定View应该如何进行渲染，从SDK 16开始，我们还可以使用ViewPropertyAnimator.alpha().withLayer()来指定。如下图所示：</p>

<p><img src="/images/android_perf_2_trans_setlayertype.png" alt="android_perf_2_trans_setlayertype" /></p>

<p>另外一个例子是包含阴影区域的View，这种类型的View并不会出现我们前面提到的问题，因为他们并不存在层叠的关系。</p>

<p><img src="/images/android_perf_2_trans_overlap.png" alt="android_perf_2_trans_overlap" /></p>

<p>为了能够让渲染器知道这种情况，避免为这种View占用额外的GPU内存空间，我们可以做下面的设置。</p>

<p><img src="/images/android_perf_2_trans_override_lap.png" alt="android_perf_2_trans_override_lap" /></p>

<p>通过上面的设置以后，性能可以得到显著的提升，如下图所示：</p>

<p><img src="/images/android_perf_2_trans_overlap_compare.png" alt="android_perf_2_trans_overlap_compare" /></p>

<h2>10)Avoiding Allocations in onDraw()</h2>

<p>我们都知道应该避免在onDraw()方法里面执行导致内存分配的操作，下面讲解下为何需要这样做。</p>

<p>首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。</p>

<p><img src="/images/android_perf_2_ondraw_gc.png" alt="android_perf_2_ondraw_gc" /></p>

<p>如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。</p>

<p>那么简单解决频繁分配内存的方法就是把分配操作移动到onDraw()方法外面，通常情况下，我们会把onDraw()里面new Paint的操作移动到外面，如下面所示：</p>

<p><img src="/images/android_perf_2_ondraw_paint.png" alt="android_perf_2_ondraw_paint" /></p>

<h2>11)Tool: Strict Mode</h2>

<p>UI线程被阻塞超过5秒，就会出现ANR，这太糟糕了。防止程序出现ANR是很重要的事情，那么如何找出程序里面潜在的坑，预防ANR呢？很多大部分情况下执行很快的方法，但是他们有可能存在巨大的隐患，这些隐患的爆发就很容易导致ANR。</p>

<p>Android提供了一个叫做Strict Mode的工具，我们可以通过手机设置里面的开发者选项，打开Strict Mode选项，如果程序存在潜在的隐患，屏幕就会闪现红色。我们也可以通过<a href="http://developer.android.com/reference/android/os/StrictMode.html">StrictMode</a> API在代码层面做细化的跟踪，可以设置StrictMode监听那些潜在问题，出现问题时如何提醒开发者，可以对屏幕闪红色，也可以输出错误日志。下面是官方的代码示例：</p>

<p>```java
public void onCreate() {</p>

<pre><code> if (DEVELOPER_MODE) {
     StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
             .detectDiskReads()
             .detectDiskWrites()
             .detectNetwork()   // or .detectAll() for all detectable problems
             .penaltyLog()
             .build());
     StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
             .detectLeakedSqlLiteObjects()
             .detectLeakedClosableObjects()
             .penaltyLog()
             .penaltyDeath()
             .build());
 }
 super.onCreate();
</code></pre>

<p>}
```</p>

<h2>12)Custom Views and Performance</h2>

<p>Android系统有提供超过70多种标准的View，例如TextView，ImageView，Button等等。在某些时候，这些标准的View无法满足我们的需要，那么就需要我们自己来实现一个View，这节会介绍如何优化自定义View的性能。</p>

<p>通常来说，针对自定义View，我们可能犯下面三个错误：</p>

<ul>
<li><strong>Useless calls to onDraw()：</strong>我们知道调用View.invalidate()会触发View的重绘，有两个原则需要遵守，第1个是仅仅在View的内容发生改变的时候才去触发invalidate方法，第2个是尽量使用ClipRect等方法来提高绘制的性能。</li>
<li><strong>Useless pixels：</strong>减少绘制时不必要的绘制元素，对于那些不可见的元素，我们需要尽量避免重绘。</li>
<li><strong>Wasted CPU cycles：</strong>对于不在屏幕上的元素，可以使用Canvas.quickReject把他们给剔除，避免浪费CPU资源。另外尽量使用GPU来进行UI的渲染，这样能够极大的提高程序的整体表现性能。</li>
</ul>


<p>最后请时刻牢记，尽量提高View的绘制性能，这样才能保证界面的刷新帧率尽量的高。更多关于这部分的内容，可以看<a href="http://hukai.me/android-performance-patterns/">这里</a></p>

<h2>13)Batching Background Work Until Later</h2>

<p>优化性能时大多数时候讨论的都是如何减少不必要的操作，但是选择何时去执行某些操作同样也很重要。在<a href="http://hukai.me/android-performance-patterns/">第1季</a>以及上一期的<a href="http://hukai.me/android-performance-battery/">性能优化之电量篇</a>里面，我们有提到过移动蜂窝模块的电量消耗模型。为了避免我们的应用程序过多的频繁消耗电量，我们需要学习如何把后台任务打包批量，并选择一个合适的时机进行触发执行。下图是每个应用程序各自执行后台任务导致的电量消耗示意图：</p>

<p><img src="/images/android_perf_2_batching_bg_1.png" alt="android_perf_2_batching_bg_1" /></p>

<p>因为像上面那样做会导致浪费很多电量，我们需要做的是把部分应用的任务延迟处理，等到一定时机，这些任务一并进行处理。结果如下面的示意图：</p>

<p><img src="/images/android_perf_2_batching_bg_2.png" alt="android_perf_2_batching_bg_2" /></p>

<p>执行延迟任务，通常有下面三种方式：</p>

<h4>1)AlarmManager</h4>

<p>使用AlarmManager设置定时任务，可以选择精确的间隔时间，也可以选择非精确时间作为参数。除非程序有很强烈的需要使用精确的定时唤醒，否者一定要避免使用他，我们应该尽量使用非精确的方式。</p>

<h4>2)SyncAdapter</h4>

<p>我们可以使用SyncAdapter为应用添加设置账户，这样在手机设置的账户列表里面可以找到我们的应用。这种方式功能更多，但是实现起来比较复杂。我们可以从这里看到官方的培训课程：<a href="http://developer.android.com/training/sync-adapters/index.html">http://developer.android.com/training/sync-adapters/index.html</a></p>

<h4>3)JobSchedulor</h4>

<p>这是最简单高效的方法，我们可以设置任务延迟的间隔，执行条件，还可以增加重试机制。</p>

<h2>14)Smaller Pixel Formats</h2>

<p>常见的png,jpeg,webp等格式的图片在设置到UI上之前需要经过解码的过程，而解压时可以选择不同的解码率，不同的解码率对内存的占用是有很大差别的。在不影响到画质的前提下尽量减少内存的占用，这能够显著提升应用程序的性能。</p>

<p>Android的Heap空间是不会自动做兼容压缩的，意思就是如果Heap空间中的图片被收回之后，这块区域并不会和其他已经回收过的区域做重新排序合并处理，那么当一个更大的图片需要放到heap之前，很可能找不到那么大的连续空闲区域，那么就会触发GC，使得heap腾出一块足以放下这张图片的空闲区域，如果无法腾出，就会发生OOM。如下图所示：</p>

<p><img src="/images/android_perf_2_pixel_heap_free.png" alt="android_perf_2_pixel_heap_free" /></p>

<p>所以为了避免加载一张超大的图片，需要尽量减少这张图片所占用的内存大小，Android为图片提供了4种解码格式，他们分别占用的内存大小如下图所示：</p>

<p><img src="/images/android_perf_2_pixel_format.png" alt="android_perf_2_pixel_format" /></p>

<p>随着解码占用内存大小的降低，清晰度也会有损失。我们需要针对不同的应用场景做不同的处理，大图和小图可以采用不同的解码率。在Android里面可以通过下面的代码来设置解码率：</p>

<p><img src="/images/android_perf_2_pixel_decode.png" alt="android_perf_2_pixel_decode" /></p>

<h2>15)Smaller PNG Files</h2>

<p>尽量减少PNG图片的大小是Android里面很重要的一条规范。相比起JPEG，PNG能够提供更加清晰无损的图片，但是PNG格式的图片会更大，占用更多的磁盘空间。到底是使用PNG还是JPEG，需要设计师仔细衡量，对于那些使用JPEG就可以达到视觉效果的，可以考虑采用JPEG即可。我们可以通过Google搜索到很多关于PNG压缩的工具，如下图所示：</p>

<p><img src="/images/android_perf_2_png_tools.png" alt="android_perf_2_png_tools" /></p>

<p>这里要介绍一种新的图片格式：Webp，它是由Google推出的一种既保留png格式的优点，又能够减少图片大小的一种新型图片格式。关于Webp的更多细节，请点击<a href="https://developers.google.com/speed/webp/?csw=1">这里</a></p>

<h2>16)Pre-scaling Bitmaps</h2>

<p>对bitmap做缩放，这也是Android里面最遇到的问题。对bitmap做缩放的意义很明显，提示显示性能，避免分配不必要的内存。Android提供了现成的bitmap缩放的API，叫做createScaledBitmap()，使用这个方法可以获取到一张经过缩放的图片。</p>

<p><img src="/images/android_perf_2_sacle_bitmap_created.png" alt="android_perf_2_sacle_bitmap_created" /></p>

<p>上面的方法能够快速的得到一张经过缩放的图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM。下面介绍其他几种缩放图片的方式。</p>

<p>inSampleSize能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点。我们会使用类似像下面一样的方法来缩放bitmap：</p>

<p><img src="/images/android_perf_2_sacle_bitmap_code.png" alt="android_perf_2_sacle_bitmap_code" /></p>

<p><img src="/images/android_perf_2_sacle_bitmap_insamplesize.png" alt="android_perf_2_sacle_bitmap_insamplesize" /></p>

<p>另外，我们还可以使用inScaled，inDensity，inTargetDensity的属性来对解码图片做处理，源码如下图所示：</p>

<p><img src="/images/android_perf_2_sacle_bitmap_inscale.png" alt="android_perf_2_sacle_bitmap_inscale" /></p>

<p>还有一个经常使用到的技巧是inJustDecodeBounds，使用这个属性去尝试解码图片，可以事先获取到图片的大小而不至于占用什么内存。如下图所示：</p>

<p><img src="/images/android_perf_2_sacle_bitmap_injust.png" alt="android_perf_2_sacle_bitmap_injust" /></p>

<h2>17)Re-using Bitmaps</h2>

<p>我们知道bitmap会占用大量的内存空间，这节会讲解什么是inBitmap属性，如何利用这个属性来提升bitmap的循环效率。前面我们介绍过使用对象池的技术来解决对象频繁创建再回收的效率问题，使用这种方法，bitmap占用的内存空间会差不多是恒定的数值，每次新创建出来的bitmap都会需要占用一块单独的内存区域，如下图所示：</p>

<p><img src="/images/android_perf_2_inbitmap_old.png" alt="android_perf_2_inbitmap_old" /></p>

<p>为了解决上图所示的效率问题，Android在解码图片的时候引进了<strong>inBitmap</strong>属性，使用这个属性可以得到下图所示的效果：</p>

<p><img src="/images/android_perf_2_inbitmap_new.png" alt="android_perf_2_inbitmap_new" /></p>

<p>使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。下面是如何使用inBitmap的代码示例：</p>

<p><img src="/images/android_perf_2_inbitmap_code.png" alt="android_perf_2_inbitmap_code" /></p>

<p>使用inBitmap需要注意几个限制条件：</p>

<ul>
<li>在SDK 11 -> 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。</li>
<li>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。</li>
</ul>


<p>我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。如下图所示：</p>

<p><img src="/images/android_perf_2_inbitmap_pool.png" alt="android_perf_2_inbitmap_pool" /></p>

<p>Google介绍了一个开源的加载bitmap的库：<a href="https://github.com/bumptech/glide">Glide</a>，这里面包含了各种对bitmap的优化技巧。</p>

<h2>18)The Performance Lifecycle</h2>

<p>大多数开发者在没有发现严重性能问题之前是不会特别花精力去关注性能优化的，通常大家关注的都是功能是否实现。当性能问题真的出现的时候，请不要慌乱。我们通常采用下面三个步骤来解决性能问题。</p>

<h4>Gather：收集数据</h4>

<p>我们可以通过Android SDK里面提供的诸多工具来收集CPU，GPU，内存，电量等等性能数据，</p>

<h4>Insight：分析数据</h4>

<p>通过上面的步骤，我们获取到了大量的数据，下一步就是分析这些数据。工具帮我们生成了很多可读性强的表格，我们需要事先了解如何查看表格的数据，每一项代表的含义，这样才能够快速定位问题。如果分析数据之后还是没有找到问题，那么就只能不停的重新收集数据，再进行分析，如此循环。</p>

<h4>Action：解决问题</h4>

<p>定位到问题之后，我们需要采取行动来解决问题。解决问题之前一定要先有个计划，评估这个解决方案是否可行，是否能够及时的解决问题。</p>

<h2>19)Tools not Rules</h2>

<p>虽然前面介绍了很多调试的方法，处理技巧，规范建议等等，可是这并不意味着所有的情况都适用，我们还是需要根据当时的情景做特定灵活的处理。</p>

<h2>20)Memory Profiling 101</h2>

<p>围绕Android生态系统，不仅仅有Phone，还有Wear，TV，Auto等等。对这些不同形态的程序进行性能优化，都离不开内存调试这个步骤。这节中介绍的内容大部分和<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>与<a href="http://hukai.me/android-performance-memory/">Android性能优化之内存篇</a>重合，不展开了。</p>

<p>首发于CSDN：<a href="http://www.csdn.net/article/2015-04-29/2824583-android-performance-patterns-season-2">Android性能优化典范（二）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化之电量篇]]></title>
    <link href="http://hukai.me/android-performance-battery/"/>
    <updated>2015-04-12T16:49:00+08:00</updated>
    <id>http://hukai.me/android-performance-battery</id>
    <content type="html"><![CDATA[<p><img src="/images/android_performance_course_udacity.jpg" alt="android_performance_course_udacity" /></p>

<p>Google近期在Udacity上发布了<a href="https://www.udacity.com/course/ud825">Android性能优化的在线课程</a>，分别从渲染，运算与内存，电量几个方面介绍了如何去优化性能，这些课程是Google之前在Youtube上发布的<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>专题课程的细化与补充。</p>

<p>下面是电量篇章的学习笔记，部分内容与前面的性能优化典范有重合，欢迎大家一起学习交流！</p>

<h3>1)Understanding Battery Drain</h3>

<p>手机各个硬件模块的耗电量是不一样的，有些模块非常耗电，而有些模块则相对显得耗电量小很多。</p>

<p><img src="/images/android_perf_battery_drain.png" alt="android_perf_battery_drain" /></p>

<p>电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗。</p>

<p>当设备处于待机状态时消耗的电量是极少的，以N5为例，打开飞行模式，可以待机接近1个月。可是点亮屏幕，硬件各个模块就需要开始工作，这会需要消耗很多电量。</p>

<p>使用WakeLock或者JobScheduler唤醒设备处理定时的任务之后，一定要及时让设备回到初始状态。每次唤醒蜂窝信号进行数据传递，都会消耗很多电量，它比WiFi等操作更加的耗电。</p>

<!-- More -->


<p><img src="/images/battery_drain_radio.png" alt="battery_drain_radio" /></p>

<h3>2)Battery Historian</h3>

<p><a href="https://developer.android.com/about/versions/android-5.0.html#Power">Battery Historian</a>是Android 5.0开始引入的新API。通过下面的指令，可以得到设备上的电量消耗信息：</p>

<p><code>bash
$ adb shell dumpsys batterystats &gt; xxx.txt  //得到整个设备的电量消耗信息
$ adb shell dumpsys batterystats &gt; com.package.name &gt; xxx.txt //得到指定app相关的电量消耗信息
</code></p>

<p>得到了原始的电量消耗数据之后，我们需要通过Google编写的一个<a href="https://github.com/google/battery-historian">python脚本</a>把数据信息转换成可读性更好的html文件：</p>

<p><code>bash
$ python historian.py xxx.txt &gt; xxx.html
</code></p>

<p>打开这个转换过后的html文件，可以看到类似TraceView生成的列表数据，这里的数据信息量很大，这里就不展开了。</p>

<p><img src="/images/android_perf_battery_historian.png" alt="android_perf_battery_historian" /></p>

<h3>3)Track Battery Status &amp; Battery Manager</h3>

<p>我们可以通过下面的代码来获取手机的当前充电状态：</p>

<p>```java
// It is very easy to subscribe to changes to the battery state, but you can get the current
// state by simply passing null in as your receiver.  Nifty, isn't that?
IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
Intent batteryStatus = this.registerReceiver(null, filter);
int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);
if (acCharge) {</p>

<pre><code>Log.v(LOG_TAG,“The phone is charging!”);
</code></pre>

<p>}
```</p>

<p>在上面的例子演示了如何立即获取到手机的充电状态，得到充电状态信息之后，我们可以有针对性的对部分代码做优化。比如我们可以判断只有当前手机为AC充电状态时
才去执行一些非常耗电的操作。</p>

<p>```java
/<em>*
 * This method checks for power by comparing the current battery state against all possible
 * plugged in states. In this case, a device may be considered plugged in either by USB, AC, or
 * wireless charge. (Wireless charge was introduced in API Level 17.)
 </em>/
private boolean checkForPower() {</p>

<pre><code>// It is very easy to subscribe to changes to the battery state, but you can get the current
// state by simply passing null in as your receiver.  Nifty, isn't that?
IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
Intent batteryStatus = this.registerReceiver(null, filter);

// There are currently three ways a device can be plugged in. We should check them all.
int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
boolean usbCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_USB);
boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);
boolean wirelessCharge = false;
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
    wirelessCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_WIRELESS);
}
return (usbCharge || acCharge || wirelessCharge);
</code></pre>

<p>}
```</p>

<h3>4)Wakelock and Battery Drain</h3>

<p>高效的保留更多的电量与不断促使用户使用你的App会消耗电量，这是矛盾的选择题。不过我们可以使用一些更好的办法来平衡两者。</p>

<p>假设你的手机里面装了大量的社交类应用，即使手机处于待机状态，也会经常被这些应用唤醒用来检查同步新的数据信息。Android会不断关闭各种硬件来延长手机的待机时间，首先屏幕会逐渐变暗直至关闭，然后CPU进入睡眠，这一切操作都是为了节约宝贵的电量资源。但是即使在这种睡眠状态下，大多数应用还是会尝试进行工作，他们将不断的唤醒手机。一个最简单的唤醒手机的方法是使用PowerManager.WakeLock的API来保持CPU工作并防止屏幕变暗关闭。这使得手机可以被唤醒，执行工作，然后回到睡眠状态。知道如何获取WakeLock是简单的，可是及时释放WakeLock也是非常重要的，不恰当的使用WakeLock会导致严重错误。例如网络请求的数据返回时间不确定，导致本来只需要10s的事情一直等待了1个小时，这样会使得电量白白浪费了。这也是为何使用带超时参数的wakelock.acquice()方法是很关键的。</p>

<p>但是仅仅设置超时并不足够解决问题，例如设置多长的超时比较合适？什么时候进行重试等等？解决上面的问题，正确的方式可能是使用非精准定时器。通常情况下，我们会设定一个时间进行某个操作，但是动态修改这个时间也许会更好。例如，如果有另外一个程序需要比你设定的时间晚5分钟唤醒，最好能够等到那个时候，两个任务捆绑一起同时进行，这就是非精确定时器的核心工作原理。我们可以定制计划的任务，可是系统如果检测到一个更好的时间，它可以推迟你的任务，以节省电量消耗。</p>

<p><img src="/images/alarmmanager_inexact_wakelock.png" alt="alarmmanager_inexact_wakelock" /></p>

<p>这正是JobScheduler API所做的事情。它会根据当前的情况与任务，组合出理想的唤醒时间，例如等到正在充电或者连接到WiFi的时候，或者集中任务一起执行。我们可以通过这个API实现很多免费的调度算法。</p>

<h3>5)Network and Battery Drain</h3>

<p>下面内容来自官方Training文档中<a href="http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html">高效下载</a>章节关于手机(Radio)蜂窝信号对电量消耗的介绍。</p>

<p>通常情况下，使用3G移动网络传输数据，电量的消耗有三种状态：</p>

<ul>
<li><strong>Full power</strong>: 能量最高的状态，移动网络连接被激活，允许设备以最大的传输速率进行操作。</li>
<li><strong>Low power</strong>: 一种中间状态，对电量的消耗差不多是Full power状态下的50%。</li>
<li><strong>Standby</strong>: 最低的状态，没有数据连接需要传输，电量消耗最少。</li>
</ul>


<p>下图是一个典型的3G Radio State Machine的图示(来自AT&amp;T，详情请点击<a href="http://www.research.att.com/articles/featured_stories/2011_03/201102_Energy_efficient?fbid=SYuI20FzBum">这里</a>):</p>

<p><img src="/images/mobile_radio_state_machine.png" title="Figure 1. Typical 3G wireless radio state machine." alt="mobile_radio_state_machine.png" /></p>

<p><strong>总之，为了减少电量的消耗，在蜂窝移动网络下，最好做到批量执行网络请求，尽量避免频繁的间隔网络请求。</strong></p>

<p>通过前面学习到的Battery Historian我们可以得到设备的电量消耗数据，如果数据中的移动蜂窝网络(Mobile Radio)电量消耗呈现下面的情况，间隔很小，又频繁断断续续的出现，说明电量消耗性能很不好：</p>

<p><img src="/images/android_perf_battery_bad.png" alt="android_perf_battery_bad.png" /></p>

<p>经过优化之后，如果呈现下面的图示，说明电量消耗的性能是良好的：</p>

<p><img src="/images/android_perf_battery_good.png" alt="android_perf_battery_good" /></p>

<p>另外WiFi连接下，网络传输的电量消耗要比移动网络少很多，应该尽量减少移动网络下的数据传输，多在WiFi环境下传输数据。</p>

<p><img src="/images/android_perf_battery_wifi.png" alt="android_perf_battery_wifi" /></p>

<p>那么如何才能够把任务缓存起来，做到批量化执行呢？下面就轮到Job Scheduler出场了。</p>

<h3>6)Using Job Scheduler</h3>

<p>使用<a href="https://developer.android.com/reference/android/app/job/JobScheduler.html">Job Scheduler</a>，应用需要做的事情就是判断哪些任务是不紧急的，可以交给Job Scheduler来处理，Job Scheduler集中处理收到的任务，选择合适的时间，合适的网络，再一起进行执行。</p>

<p>下面是使用Job Scheduler的一段简要示例，需要先有一个JobService：</p>

<p>```java
public class MyJobService extends JobService {</p>

<pre><code>private static final String LOG_TAG = "MyJobService";

@Override
public void onCreate() {
    super.onCreate();
    Log.i(LOG_TAG, "MyJobService created");
}

@Override
public void onDestroy() {
    super.onDestroy();
    Log.i(LOG_TAG, "MyJobService destroyed");
}

@Override
public boolean onStartJob(JobParameters params) {
    // This is where you would implement all of the logic for your job. Note that this runs
    // on the main thread, so you will want to use a separate thread for asynchronous work
    // (as we demonstrate below to establish a network connection).
    // If you use a separate thread, return true to indicate that you need a "reschedule" to
    // return to the job at some point in the future to finish processing the work. Otherwise,
    // return false when finished.
    Log.i(LOG_TAG, "Totally and completely working on job " + params.getJobId());
    // First, check the network, and then attempt to connect.
    if (isNetworkConnected()) {
        new SimpleDownloadTask() .execute(params);
        return true;
    } else {
        Log.i(LOG_TAG, "No connection on job " + params.getJobId() + "; sad face");
    }
    return false;
}

@Override
public boolean onStopJob(JobParameters params) {
    // Called if the job must be stopped before jobFinished() has been called. This may
    // happen if the requirements are no longer being met, such as the user no longer
    // connecting to WiFi, or the device no longer being idle. Use this callback to resolve
    // anything that may cause your application to misbehave from the job being halted.
    // Return true if the job should be rescheduled based on the retry criteria specified
    // when the job was created or return false to drop the job. Regardless of the value
    // returned, your job must stop executing.
    Log.i(LOG_TAG, "Whelp, something changed, so I'm calling it on job " + params.getJobId());
    return false;
}

/**
 * Determines if the device is currently online.
 */
private boolean isNetworkConnected() {
    ConnectivityManager connectivityManager =
            (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
    return (networkInfo != null &amp;&amp; networkInfo.isConnected());
}

/**
 *  Uses AsyncTask to create a task away from the main UI thread. This task creates a
 *  HTTPUrlConnection, and then downloads the contents of the webpage as an InputStream.
 *  The InputStream is then converted to a String, which is logged by the
 *  onPostExecute() method.
 */
private class SimpleDownloadTask extends AsyncTask&lt;JobParameters, Void, String&gt; {

    protected JobParameters mJobParam;

    @Override
    protected String doInBackground(JobParameters... params) {
        // cache system provided job requirements
        mJobParam = params[0];
        try {
            InputStream is = null;
            // Only display the first 50 characters of the retrieved web page content.
            int len = 50;

            URL url = new URL("https://www.google.com");
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setReadTimeout(10000); //10sec
            conn.setConnectTimeout(15000); //15sec
            conn.setRequestMethod("GET");
            //Starts the query
            conn.connect();
            int response = conn.getResponseCode();
            Log.d(LOG_TAG, "The response is: " + response);
            is = conn.getInputStream();

            // Convert the input stream to a string
            Reader reader = null;
            reader = new InputStreamReader(is, "UTF-8");
            char[] buffer = new char[len];
            reader.read(buffer);
            return new String(buffer);

        } catch (IOException e) {
            return "Unable to retrieve web page.";
        }
    }

    @Override
    protected void onPostExecute(String result) {
        jobFinished(mJobParam, false);
        Log.i(LOG_TAG, result);
    }
}
</code></pre>

<p>}
```</p>

<p>然后模拟通过点击Button触发N个任务，交给JobService来处理</p>

<p>```java
public class FreeTheWakelockActivity extends ActionBarActivity {</p>

<pre><code>public static final String LOG_TAG = "FreeTheWakelockActivity";

TextView mWakeLockMsg;
ComponentName mServiceComponent;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_wakelock);

    mWakeLockMsg = (TextView) findViewById(R.id.wakelock_txt);
    mServiceComponent = new ComponentName(this, MyJobService.class);
    Intent startServiceIntent = new Intent(this, MyJobService.class);
    startService(startServiceIntent);

    Button theButtonThatWakelocks = (Button) findViewById(R.id.wakelock_poll);
    theButtonThatWakelocks.setText(R.string.poll_server_button);

    theButtonThatWakelocks.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
                pollServer();
        }
    });
}

/**
 * This method polls the server via the JobScheduler API. By scheduling the job with this API,
 * your app can be confident it will execute, but without the need for a wake lock. Rather, the
 * API will take your network jobs and execute them in batch to best take advantage of the
 * initial network connection cost.
 *
 * The JobScheduler API works through a background service. In this sample, we have
 * a simple service in MyJobService to get you started. The job is scheduled here in
 * the activity, but the job itself is executed in MyJobService in the startJob() method. For
 * example, to poll your server, you would create the network connection, send your GET
 * request, and then process the response all in MyJobService. This allows the JobScheduler API
 * to invoke your logic without needed to restart your activity.
 *
 * For brevity in the sample, we are scheduling the same job several times in quick succession,
 * but again, try to consider similar tasks occurring over time in your application that can
 * afford to wait and may benefit from batching.
 */
public void pollServer() {
    JobScheduler scheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);
    for (int i=0; i&lt;10; i++) {
        JobInfo jobInfo = new JobInfo.Builder(i, mServiceComponent)
                .setMinimumLatency(5000) // 5 seconds
                .setOverrideDeadline(60000) // 60 seconds (for brevity in the sample)
                .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY) // WiFi or data connections
                .build();

        mWakeLockMsg.append("Scheduling job " + i + "!\n");
        scheduler.schedule(jobInfo);
    }
}
</code></pre>

<p>}
```</p>

<p><strong>Notes:</strong>关于更多电量优化，还有一篇文章，请点击<a href="http://developer.android.com/training/efficient-downloads/index.html">这里</a></p>
]]></content>
  </entry>
  
</feed>
